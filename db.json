{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"source/assets/blog_img/avatar.jpg","path":"assets/blog_img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1534683142034},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1534683142034},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1534683142034},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1534683142035},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1534683142035},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1534683142036},{"_id":"themes/yilia/_config.yml","hash":"d20933bfd3b893a33829e32ab2829081b1899f5d","modified":1535161777893},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1534683142036},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1534683142063},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1534683142103},{"_id":"source/_posts/Django-基础篇1.md","hash":"7750327925b6eafe1bbff6e80157aa35b817828c","modified":1535478775774},{"_id":"source/_posts/Django-基础篇2.md","hash":"e223823363d232f673b0ea028c2cf6a29a32b9a7","modified":1535558486566},{"_id":"source/_posts/Django-基础篇5.md","hash":"e9dbaa209ca156dd2f12021b761ae5f17f8f7069","modified":1536078577583},{"_id":"source/_posts/Django-基础篇3.md","hash":"0047b96b8a48e40c766601617d0f188c98dd43dd","modified":1536074362494},{"_id":"source/_posts/Django-基础篇4.md","hash":"a04021e2c1d51cfe4f6f1c20e2c78921e6418b3e","modified":1536077946421},{"_id":"source/_posts/Linux命令1-常用基本命令.md","hash":"c2cbf0da85e5bf7d66ade749a5ba88e9af3bb03f","modified":1534954142661},{"_id":"source/_posts/Linux命令2-系统管理.md","hash":"e843e5d799ce8c4f3e6a4abce963143011bd41d1","modified":1534954153372},{"_id":"source/categories/index.md","hash":"9e29d2a9fde423ebcf48445bac1668105a426193","modified":1535104468681},{"_id":"themes/yilia/.git/config","hash":"316bc92d9936dc739c39161838a28fb4641cbea2","modified":1534683142018},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1534683142010},{"_id":"themes/yilia/.git/index","hash":"ea4f7d4e1de8a72c04a0090b104b1eec81900249","modified":1535478889473},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1534682754606},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1534683142002},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1534683142038},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1534683142037},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1534683142039},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1534683142039},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1534683142040},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1534683142040},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1534683142042},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1534683142060},{"_id":"themes/yilia/layout/categories.ejs","hash":"8bc6394fbeb1cc6e98d63778b5c197a29fd076e5","modified":1535102271077},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1535102012626},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1534683142061},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1534683142061},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1534683142061},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1534683142062},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1534683142062},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1534683142103},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1534683142063},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1534683142090},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534683142058},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"b41ef91441a54503872fc763538f1267ef9dc1cf","modified":1534604049877},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1534683142101},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1534683142102},{"_id":"source/assets/blog_img/avatar.jpg","hash":"4ccbe561a23612db9caa4d692c5aa2b3d10c51d3","modified":1532691342000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1534682754622},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1534682754622},{"_id":"themes/yilia/.git/logs/HEAD","hash":"dc614d555a04c5ac8a1ed2752dcbf7192711c770","modified":1534683142015},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1534682754622},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1534683142043},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1534683142043},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1534683142044},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1534683142046},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"3bf4d19a632b9793b595cff329fdde89e40d6b76","modified":1534603965074},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1534683142046},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1534683142047},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"cb2e304c0a2a0259a1353f179ea19eaf1d5a0dc6","modified":1534603523903},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1534683142050},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1534683142049},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1534683142050},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1534683142051},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1534683142051},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1534683142052},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1534683142059},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1534683142059},{"_id":"themes/yilia/source/css/style.styl","hash":"443eab5e84f444ea57bda93bf067d6aaeecf9c00","modified":1535102270259},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1534683142091},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1534683142092},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1534683142093},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1534683142094},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1534683142095},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1534683142096},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1534683142097},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1534683142098},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1534683142099},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1534683142064},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1534683142064},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1534683142065},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1534683142065},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1534683142065},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1534683142066},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1534683142067},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1534683142067},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1534683142067},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1534683142071},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1534683142074},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1534683142074},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1534683142075},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1534683142075},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1534683142077},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1534683142078},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1534683142078},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1534683142079},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1534683142079},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1534683142079},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1534683142080},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1534683142080},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1534683142081},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1534683142081},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1534683142081},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1534683142082},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1534683142082},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1534683142084},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1534683142084},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1534683142084},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1534683142086},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1534683142087},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1534683142085},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1534683142086},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1534683142085},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1534683142087},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1534683142088},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1534683142088},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1534683142089},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1534683142058},{"_id":"themes/yilia/.git/objects/pack/pack-52418c40383c20ef5b05d15328dbbf33f9454802.idx","hash":"4d041f4766a30c4e3f2bd8aa886f1ca70f67778e","modified":1534683141837},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1534683142014},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1534683142052},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1534683142053},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1534683142053},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1534683142054},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1534683142053},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1534683142054},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1534683142055},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1534683142055},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1534683142056},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1534683142056},{"_id":"themes/yilia/source/css/_partial/categories.styl","hash":"e6219b2095a7afb426481e07f2e873cdfca414c2","modified":1535105533883},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1534683142068},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1534683142069},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1534683142069},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1534683142070},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1534683142070},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1534683142071},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1534683142072},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1534683142073},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1534683142073},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1534683142076},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1534683142076},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1534683142077},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"dc614d555a04c5ac8a1ed2752dcbf7192711c770","modified":1534683142016},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1534683142008},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"dc614d555a04c5ac8a1ed2752dcbf7192711c770","modified":1534683142008},{"_id":"themes/yilia/.git/objects/pack/pack-52418c40383c20ef5b05d15328dbbf33f9454802.pack","hash":"5c2000a86715c8182a6dbd9e1819fbcc53e87d08","modified":1534683141884},{"_id":"public/content.json","hash":"a1ed05cf66c7793a0e45875c1dd4796ca9bb3e31","modified":1536078647884},{"_id":"public/categories/index.html","hash":"fb6fb17560bcbafd79de94a9709ade2d3db07540","modified":1536078647970},{"_id":"public/2018/08/30/Django-基础篇5/index.html","hash":"55710a6d518597f1c07c101496b0ab5d1bfa514c","modified":1536078647970},{"_id":"public/2018/08/30/Django-基础篇4/index.html","hash":"5a2cb5fec1b97d4f5b8abcb761d49d1e84796caa","modified":1536078647970},{"_id":"public/2018/08/30/Django-基础篇3/index.html","hash":"595129df75292d0f2b6edffff67938bf28553b8a","modified":1536078647970},{"_id":"public/2018/08/28/Django-基础篇2/index.html","hash":"f87061e48e537d8a79d8aa4c06c0471ea85663d3","modified":1536078647970},{"_id":"public/2018/08/22/Django-基础篇1/index.html","hash":"ee5391b2ec4b3d646629c079e5f33683337a55a8","modified":1536078647970},{"_id":"public/2018/08/18/Linux命令2-系统管理/index.html","hash":"9401aa229d7e9c74f9079ca65545b6dc9b7a5aa3","modified":1536078647970},{"_id":"public/2018/07/22/Linux命令1-常用基本命令/index.html","hash":"c3c7a6ef55f52f5edd7bed01b8572bafea5ed9f9","modified":1536078647970},{"_id":"public/index.html","hash":"7f209403e5df389d3a402106e4e454ea2f120d03","modified":1536078647971},{"_id":"public/archives/index.html","hash":"20d965b3324e99a4194d05519a06a462de692a7e","modified":1536078647971},{"_id":"public/archives/2018/index.html","hash":"bd10736c9c14ffcebe27ac73e0e22936e6eacb77","modified":1536078647971},{"_id":"public/archives/2018/07/index.html","hash":"657acd447f2a5cc52ff7e2c53af32da53fd9b78c","modified":1536078647971},{"_id":"public/archives/2018/08/index.html","hash":"6fca57f774cf40980ea763e6324794a0a0c8dfc9","modified":1536078647971},{"_id":"public/tags/Django/index.html","hash":"d096d62d5a3e52d92d4fa955076bdbf31f67d1ab","modified":1536078647971},{"_id":"public/tags/Linux/index.html","hash":"684af1d47aa5df8d20f510019b5ad3d586ea2a24","modified":1536078647971},{"_id":"public/assets/blog_img/avatar.jpg","hash":"4ccbe561a23612db9caa4d692c5aa2b3d10c51d3","modified":1536078648004},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1536078648004},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1536078648004},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1536078648004},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1536078648004},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1536078648004},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1536078648004},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1536078648005},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1536078648005},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1536078648005},{"_id":"public/css/style.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536078648658},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1536078648682},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1536078648704},{"_id":"public/main.0cf68a.css","hash":"10769fdb6239d581146cf970bb36413a304c5d3d","modified":1536078648707},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1536078648711}],"Category":[],"Data":[],"Page":[{"title":"文章分类","date":"2018-08-24T08:57:24.000Z","type":"categories","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-08-24 16:57:24\ntype: \"categories\"\nlayout: \"categories\"\ncomments: false\n---\n","updated":"2018-08-24T09:54:28.681Z","path":"categories/index.html","_id":"cjlnxkcz60005pstf4ng63izf","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Django-基础篇1","date":"2018-08-22T15:06:33.000Z","_content":"\n## 一. 搭建虚拟环境 \n- 搭建虚拟环境的目的是为了避免：当我们想开发多个不同的项目，需要用到同一个包的不同版本时，  如果在同一个目录安装或更新，可能造成其他的项目无法运行\n- 虚拟环境可以搭建独立的Python运行环境，使得单个项目的运行环境与其他项目互不影响\n- 所有的虚拟环境，都位于/home/下的隐藏目录.virtualenvs下\n\n<!--more-->\n### 1. 创建虚拟环境\n- 安装虚拟环境的命令如下：\n    + sudo pip install virtualenv\n    + sudo pip install virtualenvwrapper\n\n- 创建虚拟环境的命令如下:\n    + mkvirtualenv 虚拟环境名称 \n    \n    + 栗子(创建成功后会自动工作在这个虚拟环境上)：\n    + mkvirtualenv py_django \n     \n    {% qnimg mk.png %}\n\n- 退出虚拟环境的命令如下：\n    + deactivate  \n    \n    {% qnimg deactivate.png %}\n\n\n- 查看所有虚拟环境的命令如下：\n    + workon  \n\n    {% qnimg workon.png %}\n\n- 使用虚拟环境的命令如下：\n    + workon 虚拟环境名称  \n\n    {% qnimg workon_one.png %}\n\n- 删除虚拟环境的命令如下：\n    + rmvirtualenv 虚拟环境名称  \n\n    {% qnimg del.png %}\n\n\n## 二. 安装django包\n- 先按前面创建虚拟环境的命名创建一个虚拟环境\n    + mkvirtualenv py_django\n\n- 安装Django包命令如下：\n    + pip install django\n    + （通过上面命令安装的版本是最新的版本，也可以通过下面的命令安装指定的版本）\n    + 栗子：pip install django==1.11.3\n\n\n","source":"_posts/Django-基础篇1.md","raw":"---\ntitle: Django-基础篇1\ndate: 2018-08-22 23:06:33\ntags: Django\n---\n\n## 一. 搭建虚拟环境 \n- 搭建虚拟环境的目的是为了避免：当我们想开发多个不同的项目，需要用到同一个包的不同版本时，  如果在同一个目录安装或更新，可能造成其他的项目无法运行\n- 虚拟环境可以搭建独立的Python运行环境，使得单个项目的运行环境与其他项目互不影响\n- 所有的虚拟环境，都位于/home/下的隐藏目录.virtualenvs下\n\n<!--more-->\n### 1. 创建虚拟环境\n- 安装虚拟环境的命令如下：\n    + sudo pip install virtualenv\n    + sudo pip install virtualenvwrapper\n\n- 创建虚拟环境的命令如下:\n    + mkvirtualenv 虚拟环境名称 \n    \n    + 栗子(创建成功后会自动工作在这个虚拟环境上)：\n    + mkvirtualenv py_django \n     \n    {% qnimg mk.png %}\n\n- 退出虚拟环境的命令如下：\n    + deactivate  \n    \n    {% qnimg deactivate.png %}\n\n\n- 查看所有虚拟环境的命令如下：\n    + workon  \n\n    {% qnimg workon.png %}\n\n- 使用虚拟环境的命令如下：\n    + workon 虚拟环境名称  \n\n    {% qnimg workon_one.png %}\n\n- 删除虚拟环境的命令如下：\n    + rmvirtualenv 虚拟环境名称  \n\n    {% qnimg del.png %}\n\n\n## 二. 安装django包\n- 先按前面创建虚拟环境的命名创建一个虚拟环境\n    + mkvirtualenv py_django\n\n- 安装Django包命令如下：\n    + pip install django\n    + （通过上面命令安装的版本是最新的版本，也可以通过下面的命令安装指定的版本）\n    + 栗子：pip install django==1.11.3\n\n\n","slug":"Django-基础篇1","published":1,"updated":"2018-08-28T17:52:55.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkcyk0000pstf7agevk6j","content":"<h2 id=\"一-搭建虚拟环境\"><a href=\"#一-搭建虚拟环境\" class=\"headerlink\" title=\"一. 搭建虚拟环境\"></a>一. 搭建虚拟环境</h2><ul>\n<li>搭建虚拟环境的目的是为了避免：当我们想开发多个不同的项目，需要用到同一个包的不同版本时，  如果在同一个目录安装或更新，可能造成其他的项目无法运行</li>\n<li>虚拟环境可以搭建独立的Python运行环境，使得单个项目的运行环境与其他项目互不影响</li>\n<li>所有的虚拟环境，都位于/home/下的隐藏目录.virtualenvs下</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"1-创建虚拟环境\"><a href=\"#1-创建虚拟环境\" class=\"headerlink\" title=\"1. 创建虚拟环境\"></a>1. 创建虚拟环境</h3><ul>\n<li><p>安装虚拟环境的命令如下：</p>\n<ul>\n<li>sudo pip install virtualenv</li>\n<li>sudo pip install virtualenvwrapper</li>\n</ul>\n</li>\n<li><p>创建虚拟环境的命令如下:</p>\n<ul>\n<li><p>mkvirtualenv 虚拟环境名称 </p>\n</li>\n<li><p>栗子(创建成功后会自动工作在这个虚拟环境上)：</p>\n</li>\n<li><p>mkvirtualenv py_django </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/mk.png\">\n</li>\n</ul>\n</li>\n<li><p>退出虚拟环境的命令如下：</p>\n<ul>\n<li><p>deactivate  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/deactivate.png\">\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>查看所有虚拟环境的命令如下：</p>\n<ul>\n<li><p>workon  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/workon.png\">\n</li>\n</ul>\n</li>\n<li><p>使用虚拟环境的命令如下：</p>\n<ul>\n<li><p>workon 虚拟环境名称  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/workon_one.png\">\n</li>\n</ul>\n</li>\n<li><p>删除虚拟环境的命令如下：</p>\n<ul>\n<li><p>rmvirtualenv 虚拟环境名称  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/del.png\">\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-安装django包\"><a href=\"#二-安装django包\" class=\"headerlink\" title=\"二. 安装django包\"></a>二. 安装django包</h2><ul>\n<li><p>先按前面创建虚拟环境的命名创建一个虚拟环境</p>\n<ul>\n<li>mkvirtualenv py_django</li>\n</ul>\n</li>\n<li><p>安装Django包命令如下：</p>\n<ul>\n<li>pip install django</li>\n<li>（通过上面命令安装的版本是最新的版本，也可以通过下面的命令安装指定的版本）</li>\n<li>栗子：pip install django==1.11.3</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一-搭建虚拟环境\"><a href=\"#一-搭建虚拟环境\" class=\"headerlink\" title=\"一. 搭建虚拟环境\"></a>一. 搭建虚拟环境</h2><ul>\n<li>搭建虚拟环境的目的是为了避免：当我们想开发多个不同的项目，需要用到同一个包的不同版本时，  如果在同一个目录安装或更新，可能造成其他的项目无法运行</li>\n<li>虚拟环境可以搭建独立的Python运行环境，使得单个项目的运行环境与其他项目互不影响</li>\n<li>所有的虚拟环境，都位于/home/下的隐藏目录.virtualenvs下</li>\n</ul>","more":"<h3 id=\"1-创建虚拟环境\"><a href=\"#1-创建虚拟环境\" class=\"headerlink\" title=\"1. 创建虚拟环境\"></a>1. 创建虚拟环境</h3><ul>\n<li><p>安装虚拟环境的命令如下：</p>\n<ul>\n<li>sudo pip install virtualenv</li>\n<li>sudo pip install virtualenvwrapper</li>\n</ul>\n</li>\n<li><p>创建虚拟环境的命令如下:</p>\n<ul>\n<li><p>mkvirtualenv 虚拟环境名称 </p>\n</li>\n<li><p>栗子(创建成功后会自动工作在这个虚拟环境上)：</p>\n</li>\n<li><p>mkvirtualenv py_django </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/mk.png\">\n</li>\n</ul>\n</li>\n<li><p>退出虚拟环境的命令如下：</p>\n<ul>\n<li><p>deactivate  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/deactivate.png\">\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>查看所有虚拟环境的命令如下：</p>\n<ul>\n<li><p>workon  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/workon.png\">\n</li>\n</ul>\n</li>\n<li><p>使用虚拟环境的命令如下：</p>\n<ul>\n<li><p>workon 虚拟环境名称  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/workon_one.png\">\n</li>\n</ul>\n</li>\n<li><p>删除虚拟环境的命令如下：</p>\n<ul>\n<li><p>rmvirtualenv 虚拟环境名称  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/del.png\">\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-安装django包\"><a href=\"#二-安装django包\" class=\"headerlink\" title=\"二. 安装django包\"></a>二. 安装django包</h2><ul>\n<li><p>先按前面创建虚拟环境的命名创建一个虚拟环境</p>\n<ul>\n<li>mkvirtualenv py_django</li>\n</ul>\n</li>\n<li><p>安装Django包命令如下：</p>\n<ul>\n<li>pip install django</li>\n<li>（通过上面命令安装的版本是最新的版本，也可以通过下面的命令安装指定的版本）</li>\n<li>栗子：pip install django==1.11.3</li>\n</ul>\n</li>\n</ul>"},{"title":"Django-基础篇5-表单","date":"2018-08-29T16:14:44.000Z","_content":"\n\n- 表单字段\n    + 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html\n   \n- 表单验证\n- 表单API\n\n- 一个简单的表单\n    + 投票详细页面的模板（“polls/detail.html”）\n    ```\n    polls/templates/polls/detail.html\n\n\n    <h1>{{ question.question_text }}</h1>\n    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}\n    <form action=\"{% url 'polls:vote' question.id %}\" method=\"post\">\n    {% csrf_token %}\n    {% for choice in question.choice_set.all %}\n        <input type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\" />\n        <label for=\"choice{{ forloop.counter }}\">{{ choice.choice_text }}</label><br />\n    {% endfor %}\n    <input type=\"submit\" value=\"Vote\" />\n    </form>\n\n\n    ```\n\n\n    + 简要说明：\n在detail网页模板中，我们为Question对应的每个Choice都添加了一个单选按钮用于选择。 每个单选按钮的value属性是对应的各个Choice的ID。 每个单选按钮的name是\"choice\"。 这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个POST数据choice=#，其中# 为选择的Choice的ID。\n   \n    + 设置表单的action路径，并设置 method=\"post\"。\n    + url配置:\n    ```\n    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n\n    ```\n\n\n#### 构建一个表单\n- 模板：\n    ```\n    <form action=\"/your-name/\" method=\"post\">\n        <label for=\"your_name\">Your name: </label>\n        <input id=\"your_name\" type=\"text\" name=\"your_name\" value=\"{{ current_name }}\">\n        <input type=\"submit\" value=\"OK\">\n    </form>\n\n\n    ```\n\n- 创建一个表单\n    ```\n    forms.py\n\n    from django import forms\n    class NameForm(forms.Form):\n        your_name = forms.CharField(label='Your name', max_length=100)\n\n    ```\n\n    + 它定义一个Form 类，只带有一个字段（your_name）。 我们已经对这个字段使用一个人性化的标签，当渲染时它将出现在<label> 中（在这个例子中，即使我们省略它，我们指定的label还是会自动生成）。\n    + Form 的实例具有一个is_valid() 方法，它为所有的字段运行验证的程序。  当调用这个方法时，如果所有的字段都包含合法的数据，它将：\n        * 返回True\n        * 将表单的数据放到cleaned_data 属性中。\n       \n    + 完整的表单，第一次渲染时，看上去将像：\n    ```\n    <label for=\"your_name\">Your name: </label>\n    <input id=\"your_name\" type=\"text\" name=\"your_name\" maxlength=\"100\" required />\n\n\n    注意它不包含 <form> 标签和提交按钮。 我们必须自己在模板中提供它们。\n\n    ```\n\n- 视图\n    + 我们要在视图中实例化它。\n    ```\n    views.py\n\n    from django.shortcuts import render\n    from django.http import HttpResponseRedirect\n    from .forms import NameForm\n    def get_name(request):\n        # 如果这是一个POST请求,我们就需要处理表单数据\n        if request.method == 'POST':\n            # 创建一个表单实例,并且使用表单数据填充request请求:\n            form = NameForm(request.POST)\n            # 检查数据有效性:\n            if form.is_valid():\n                # 在需要时，可以在form.cleaned_date中处理数据\n                # ...\n                # 重定向到一个新的URL:\n                return HttpResponseRedirect('/thanks/')\n    # 如果是GET或者其它请求方法，我们将创建一个空的表单。\n        else:\n            form = NameForm()\n    return render(request, 'name.html', {'form': form})\n\n\n    ```\n\n    + 如果访问视图的是一个GET 请求，<font color=\"red\">它将创建一个空的表单实例并将它放置到要渲染的模板的上下文中。 这是我们在第一次访问该URL 时预期发生的情况。</font>\n","source":"_posts/Django-基础篇5.md","raw":"---\ntitle: Django-基础篇5-表单\ndate: 2018-08-30 00:14:44\ntags:\n---\n\n\n- 表单字段\n    + 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html\n   \n- 表单验证\n- 表单API\n\n- 一个简单的表单\n    + 投票详细页面的模板（“polls/detail.html”）\n    ```\n    polls/templates/polls/detail.html\n\n\n    <h1>{{ question.question_text }}</h1>\n    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}\n    <form action=\"{% url 'polls:vote' question.id %}\" method=\"post\">\n    {% csrf_token %}\n    {% for choice in question.choice_set.all %}\n        <input type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\" />\n        <label for=\"choice{{ forloop.counter }}\">{{ choice.choice_text }}</label><br />\n    {% endfor %}\n    <input type=\"submit\" value=\"Vote\" />\n    </form>\n\n\n    ```\n\n\n    + 简要说明：\n在detail网页模板中，我们为Question对应的每个Choice都添加了一个单选按钮用于选择。 每个单选按钮的value属性是对应的各个Choice的ID。 每个单选按钮的name是\"choice\"。 这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个POST数据choice=#，其中# 为选择的Choice的ID。\n   \n    + 设置表单的action路径，并设置 method=\"post\"。\n    + url配置:\n    ```\n    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n\n    ```\n\n\n#### 构建一个表单\n- 模板：\n    ```\n    <form action=\"/your-name/\" method=\"post\">\n        <label for=\"your_name\">Your name: </label>\n        <input id=\"your_name\" type=\"text\" name=\"your_name\" value=\"{{ current_name }}\">\n        <input type=\"submit\" value=\"OK\">\n    </form>\n\n\n    ```\n\n- 创建一个表单\n    ```\n    forms.py\n\n    from django import forms\n    class NameForm(forms.Form):\n        your_name = forms.CharField(label='Your name', max_length=100)\n\n    ```\n\n    + 它定义一个Form 类，只带有一个字段（your_name）。 我们已经对这个字段使用一个人性化的标签，当渲染时它将出现在<label> 中（在这个例子中，即使我们省略它，我们指定的label还是会自动生成）。\n    + Form 的实例具有一个is_valid() 方法，它为所有的字段运行验证的程序。  当调用这个方法时，如果所有的字段都包含合法的数据，它将：\n        * 返回True\n        * 将表单的数据放到cleaned_data 属性中。\n       \n    + 完整的表单，第一次渲染时，看上去将像：\n    ```\n    <label for=\"your_name\">Your name: </label>\n    <input id=\"your_name\" type=\"text\" name=\"your_name\" maxlength=\"100\" required />\n\n\n    注意它不包含 <form> 标签和提交按钮。 我们必须自己在模板中提供它们。\n\n    ```\n\n- 视图\n    + 我们要在视图中实例化它。\n    ```\n    views.py\n\n    from django.shortcuts import render\n    from django.http import HttpResponseRedirect\n    from .forms import NameForm\n    def get_name(request):\n        # 如果这是一个POST请求,我们就需要处理表单数据\n        if request.method == 'POST':\n            # 创建一个表单实例,并且使用表单数据填充request请求:\n            form = NameForm(request.POST)\n            # 检查数据有效性:\n            if form.is_valid():\n                # 在需要时，可以在form.cleaned_date中处理数据\n                # ...\n                # 重定向到一个新的URL:\n                return HttpResponseRedirect('/thanks/')\n    # 如果是GET或者其它请求方法，我们将创建一个空的表单。\n        else:\n            form = NameForm()\n    return render(request, 'name.html', {'form': form})\n\n\n    ```\n\n    + 如果访问视图的是一个GET 请求，<font color=\"red\">它将创建一个空的表单实例并将它放置到要渲染的模板的上下文中。 这是我们在第一次访问该URL 时预期发生的情况。</font>\n","slug":"Django-基础篇5","published":1,"updated":"2018-09-04T16:29:37.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkcyp0001pstfyksb6jw9","content":"<ul>\n<li><p>表单字段</p>\n<ul>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html</a></li>\n</ul>\n</li>\n<li><p>表单验证</p>\n</li>\n<li><p>表单API</p>\n</li>\n<li><p>一个简单的表单</p>\n<ul>\n<li><p>投票详细页面的模板（“polls/detail.html”）</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\">polls/templates/polls/detail.html</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">if</span></span> error_message %&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; error_message &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endif</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"</span></span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">url</span></span> 'polls:vote' question.id %&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">csrf_token</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">for</span></span> choice <span class=\"keyword\">in</span> question.choice_set.all %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"choice\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"choice</span></span></span><span class=\"template-variable\">&#123;&#123; forloop.counter &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"</span></span></span><span class=\"template-variable\">&#123;&#123; choice.id &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"choice</span></span></span><span class=\"template-variable\">&#123;&#123; forloop.counter &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; choice.choice_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endfor</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Vote\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简要说明：<br>在detail网页模板中，我们为Question对应的每个Choice都添加了一个单选按钮用于选择。 每个单选按钮的value属性是对应的各个Choice的ID。 每个单选按钮的name是”choice”。 这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个POST数据choice=#，其中# 为选择的Choice的ID。</p>\n</li>\n<li><p>设置表单的action路径，并设置 method=”post”。</p>\n</li>\n<li>url配置:<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/vote/$'</span>, views.vote, name=<span class=\"string\">'vote'</span>),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"构建一个表单\"><a href=\"#构建一个表单\" class=\"headerlink\" title=\"构建一个表单\"></a>构建一个表单</h4><ul>\n<li><p>模板：</p>\n  <figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> action=<span class=\"string\">\"/your-name/\"</span> method=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">label</span> <span class=\"keyword\">for</span>=<span class=\"string\">\"your_name\"</span>&gt;Your name: &lt;/<span class=\"keyword\">label</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">input</span> id=<span class=\"string\">\"your_name\"</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"your_name\"</span> value=<span class=\"string\">\"&#123;&#123; current_name &#125;&#125;\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"submit\"</span> value=<span class=\"string\">\"OK\"</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个表单</p>\n  <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">forms</span>.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">from</span> django <span class=\"keyword\">import</span> forms</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">NameForm</span>(<span class=\"title\">forms</span>.<span class=\"type\">Form</span>):</span></span><br><span class=\"line\"><span class=\"class\">    your_name = forms.<span class=\"type\">CharField</span>(<span class=\"title\">label</span>='<span class=\"type\">Your</span> <span class=\"title\">name'</span>, <span class=\"title\">max_length</span>=100)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>它定义一个Form 类，只带有一个字段（your_name）。 我们已经对这个字段使用一个人性化的标签，当渲染时它将出现在<label> 中（在这个例子中，即使我们省略它，我们指定的label还是会自动生成）。</label></li>\n<li><p>Form 的实例具有一个is_valid() 方法，它为所有的字段运行验证的程序。  当调用这个方法时，如果所有的字段都包含合法的数据，它将：</p>\n<ul>\n<li>返回True</li>\n<li>将表单的数据放到cleaned_data 属性中。</li>\n</ul>\n</li>\n<li><p>完整的表单，第一次渲染时，看上去将像：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">label</span> <span class=\"keyword\">for</span>=<span class=\"string\">\"your_name\"</span>&gt;Your name: &lt;/<span class=\"keyword\">label</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"keyword\">input</span> id=<span class=\"string\">\"your_name\"</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"your_name\"</span> maxlength=<span class=\"string\">\"100\"</span> required /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意它不包含 &lt;<span class=\"keyword\">form</span>&gt; 标签和提交按钮。 我们必须自己在模板中提供它们。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>视图</p>\n<ul>\n<li><p>我们要在视图中实例化它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> render</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</span><br><span class=\"line\"><span class=\"keyword\">from</span> .forms <span class=\"keyword\">import</span> NameForm</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_name</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果这是一个POST请求,我们就需要处理表单数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">'POST'</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 创建一个表单实例,并且使用表单数据填充request请求:</span></span><br><span class=\"line\">        form = NameForm(request.POST)</span><br><span class=\"line\">        <span class=\"comment\"># 检查数据有效性:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> form.is_valid():</span><br><span class=\"line\">            <span class=\"comment\"># 在需要时，可以在form.cleaned_date中处理数据</span></span><br><span class=\"line\">            <span class=\"comment\"># ...</span></span><br><span class=\"line\">            <span class=\"comment\"># 重定向到一个新的URL:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> HttpResponseRedirect(<span class=\"string\">'/thanks/'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 如果是GET或者其它请求方法，我们将创建一个空的表单。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        form = NameForm()</span><br><span class=\"line\"><span class=\"keyword\">return</span> render(request, <span class=\"string\">'name.html'</span>, &#123;<span class=\"string\">'form'</span>: form&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果访问视图的是一个GET 请求，<font color=\"red\">它将创建一个空的表单实例并将它放置到要渲染的模板的上下文中。 这是我们在第一次访问该URL 时预期发生的情况。</font></p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>表单字段</p>\n<ul>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html</a></li>\n</ul>\n</li>\n<li><p>表单验证</p>\n</li>\n<li><p>表单API</p>\n</li>\n<li><p>一个简单的表单</p>\n<ul>\n<li><p>投票详细页面的模板（“polls/detail.html”）</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\">polls/templates/polls/detail.html</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">if</span></span> error_message %&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; error_message &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endif</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"</span></span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">url</span></span> 'polls:vote' question.id %&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">csrf_token</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">for</span></span> choice <span class=\"keyword\">in</span> question.choice_set.all %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"choice\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"choice</span></span></span><span class=\"template-variable\">&#123;&#123; forloop.counter &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"</span></span></span><span class=\"template-variable\">&#123;&#123; choice.id &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"choice</span></span></span><span class=\"template-variable\">&#123;&#123; forloop.counter &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; choice.choice_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endfor</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Vote\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简要说明：<br>在detail网页模板中，我们为Question对应的每个Choice都添加了一个单选按钮用于选择。 每个单选按钮的value属性是对应的各个Choice的ID。 每个单选按钮的name是”choice”。 这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一个POST数据choice=#，其中# 为选择的Choice的ID。</p>\n</li>\n<li><p>设置表单的action路径，并设置 method=”post”。</p>\n</li>\n<li>url配置:<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/vote/$'</span>, views.vote, name=<span class=\"string\">'vote'</span>),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"构建一个表单\"><a href=\"#构建一个表单\" class=\"headerlink\" title=\"构建一个表单\"></a>构建一个表单</h4><ul>\n<li><p>模板：</p>\n  <figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> action=<span class=\"string\">\"/your-name/\"</span> method=<span class=\"string\">\"post\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">label</span> <span class=\"keyword\">for</span>=<span class=\"string\">\"your_name\"</span>&gt;Your name: &lt;/<span class=\"keyword\">label</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">input</span> id=<span class=\"string\">\"your_name\"</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"your_name\"</span> value=<span class=\"string\">\"&#123;&#123; current_name &#125;&#125;\"</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"submit\"</span> value=<span class=\"string\">\"OK\"</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个表单</p>\n  <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">forms</span>.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">from</span> django <span class=\"keyword\">import</span> forms</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">NameForm</span>(<span class=\"title\">forms</span>.<span class=\"type\">Form</span>):</span></span><br><span class=\"line\"><span class=\"class\">    your_name = forms.<span class=\"type\">CharField</span>(<span class=\"title\">label</span>='<span class=\"type\">Your</span> <span class=\"title\">name'</span>, <span class=\"title\">max_length</span>=100)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>它定义一个Form 类，只带有一个字段（your_name）。 我们已经对这个字段使用一个人性化的标签，当渲染时它将出现在<label> 中（在这个例子中，即使我们省略它，我们指定的label还是会自动生成）。</label></li>\n<li><p>Form 的实例具有一个is_valid() 方法，它为所有的字段运行验证的程序。  当调用这个方法时，如果所有的字段都包含合法的数据，它将：</p>\n<ul>\n<li>返回True</li>\n<li>将表单的数据放到cleaned_data 属性中。</li>\n</ul>\n</li>\n<li><p>完整的表单，第一次渲染时，看上去将像：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">label</span> <span class=\"keyword\">for</span>=<span class=\"string\">\"your_name\"</span>&gt;Your name: &lt;/<span class=\"keyword\">label</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"keyword\">input</span> id=<span class=\"string\">\"your_name\"</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"your_name\"</span> maxlength=<span class=\"string\">\"100\"</span> required /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意它不包含 &lt;<span class=\"keyword\">form</span>&gt; 标签和提交按钮。 我们必须自己在模板中提供它们。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>视图</p>\n<ul>\n<li><p>我们要在视图中实例化它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> render</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</span><br><span class=\"line\"><span class=\"keyword\">from</span> .forms <span class=\"keyword\">import</span> NameForm</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_name</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果这是一个POST请求,我们就需要处理表单数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">'POST'</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 创建一个表单实例,并且使用表单数据填充request请求:</span></span><br><span class=\"line\">        form = NameForm(request.POST)</span><br><span class=\"line\">        <span class=\"comment\"># 检查数据有效性:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> form.is_valid():</span><br><span class=\"line\">            <span class=\"comment\"># 在需要时，可以在form.cleaned_date中处理数据</span></span><br><span class=\"line\">            <span class=\"comment\"># ...</span></span><br><span class=\"line\">            <span class=\"comment\"># 重定向到一个新的URL:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> HttpResponseRedirect(<span class=\"string\">'/thanks/'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 如果是GET或者其它请求方法，我们将创建一个空的表单。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        form = NameForm()</span><br><span class=\"line\"><span class=\"keyword\">return</span> render(request, <span class=\"string\">'name.html'</span>, &#123;<span class=\"string\">'form'</span>: form&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果访问视图的是一个GET 请求，<font color=\"red\">它将创建一个空的表单实例并将它放置到要渲染的模板的上下文中。 这是我们在第一次访问该URL 时预期发生的情况。</font></p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Django-基础篇3-视图与模板","date":"2018-08-29T16:10:49.000Z","_content":"\n\n每个视图函数只负责处理两件事中的一件：返回一个包含所请求页面内容的 HttpResponse对象，或抛出一个诸如Http404异常。\n\n- 视图中使用模板：\n    ```\n    polls/views.py\n\n    from django.http import HttpResponse\n    from django.template import loader\n    from .models import Question\n    def index(request):\n        latest_question_list = Question.objects.order_by('-pub_date')[:5]\n        template = loader.get_template('polls/index.html')\n        context = {\n            'latest_question_list': latest_question_list,\n        }\n        return HttpResponse(template.render(context, request))\n\n\n    ```\n\n\n- 快捷方式：render()\n    + Django的快捷函数:https://yiyibooks.cn/xx/Django_1.11.6/topics/http/shortcuts.html#django.shortcuts.render\n    + render()函数将请求对象作为它的第一个参数，模板的名字作为它的第二个参数，一个字典作为它可选的第三个参数。 <font color=\"\">它返回一个HttpResponse对象，含有用给定的context 渲染后的模板。</font>\n\n\n- 抛出404异常\n    + 现在，让我们处理Question 详细页面的视图 —— 显示Question内容的页面： 下面是该视图：\n    + 如果没有找到所请求ID的Question，这个视图引发一个Http404异常。\n    ```\n    polls/views.py\n\n    from django.http import Http404\n    from django.shortcuts import render\n    from .models import Question\n    # ...\n    def detail(request, question_id):\n        try:\n            question = Question.objects.get(pk=question_id)\n        except Question.DoesNotExist:\n            raise Http404(\"Question does not exist\")\n        return render(request, 'polls/detail.html', {'question': question})\n\n\n    ```\n\n- 一个快捷方式：get_object_or_404() \n    + 一种常见的习惯是使用get()并在对象不存在时引发Http404。 Django为此提供一个快捷方式。 下面是重写后的detail()视图：\n    ```\n    polls/views.py\n\n    from django.shortcuts import get_object_or_404, render\n    from .models import Question\n    # ...\n    def detail(request, question_id):\n        question = get_object_or_404(Question, pk=question_id)\n        return render(request, 'polls/detail.html', {'question': question})\n\n    ```\n    + get_object_or_404() 函数将一个Django模型作为它的第一个参数，任意数量的关键字参数作为它的第二个参数，它会将这些关键字参数传递给模型管理器中的get() 函数。 如果对象不存在，它就引发一个 Http404异常。\n    + 还有一个get_list_or_404()函数，它的工作方式类似get_object_or_404() —— 差别在于它使用filter()而不是get()。 如果列表为空则引发Http404。\n\n\n\n- 移除模板中的硬编码\n    + 原来：\n    ```\n     <li><a href=\"/polls/{{ question.id }}/\">{{ question.question_text }}</a></li>\n\n    ```\n\n    + 修改后：\n    ```\n    <li><a href=\"{% url 'detail' question.id %}\">{{ question.question_text }}</a></li>\n\n\n    # the 'name' value as called by the {% url %} template tag\n    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n\n    ```\n\n    + 好处：\n        * 如果你想把polls应用中detail视图的URL改成其它样子比如polls/specifics/12/，就可以不必在该模板（或者多个模板）中修改它，只需要修改polls/urls.py：\n        ```\n        # added the word 'specifics'\n        url(r'^specifics/(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n        ```\n\n\n- 命名空间URL名称\n    + 在polls/urls.py文件中，继续添加app_name来设置应用程序命名空间：\n    ```\n    polls/urls.py\n\n    from django.conf.urls import url\n    from . import views\n    app_name = 'polls'\n    urlpatterns = [\n        url(r'^$', views.index, name='index'),\n        url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n        url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),\n        url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n    ]\n\n    ```\n\n    + 现在将你的模板polls/index.html由：\n    ```\n    polls/templates/polls/index.html\n    <li><a href=\"{% url 'detail' question.id %}\">{{ question.question_text }}</a></li>\n\n\n    修改为指向具有命名空间的详细视图：\n    polls/templates/polls/index.html\n    <li><a href=\"{% url 'polls:detail' question.id %}\">{{ question.question_text }}</a></li>\n\n    ```\n\n- 一个vote()函数的模拟实现\n    ```\n    polls/views.py\n\n    from django.shortcuts import get_object_or_404, render\n    from django.http import HttpResponseRedirect, HttpResponse\n    from django.urls import reverse\n    from .models import Choice, Question\n    # ...\n    def vote(request, question_id):\n        question = get_object_or_404(Question, pk=question_id)\n        try:\n            selected_choice = question.choice_set.get(pk=request.POST['choice'])\n        except (KeyError, Choice.DoesNotExist):\n            # 重新显示该问题的表单\n            return render(request, 'polls/detail.html', {\n                'question': question,\n                'error_message': \"You didn't select a choice.\",\n            })\n        else:\n            selected_choice.votes += 1\n            selected_choice.save()\n            # 始终在成功处理 POST 数据后返回一个 HttpResponseRedirect ，\n            # （合并上句） 这样可以防止用户点击“后退”按钮时数据被发送两次。\n            # （合并至上一句）\n            return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))\n\n\n    ```\n\n    + request.POST 是一个类似字典的对象，让你可以通过关键字的名字获取提交的数据。\n    + 如果在POST数据中没有提供request.POST['choice']，choice将引发一个KeyError。 上面的代码检查KeyError，如果没有给出choice将重新显示Question表单和一个错误信息。\n    + 异常参考：https://docs.python.org/3/library/exceptions.html\n    + 在增加Choice的得票数之后，<font color=\"red\">代码返回一个 HttpResponseRedirect而不是常用的HttpResponse。 HttpResponseRedirect只接收一个参数：用户将要被重定向的URL</font>\n    + 在这个例子中，我们在HttpResponseRedirect的构造函数中使用reverse()函数。 这个函数避免了我们在视图函数中硬编码URL。 它需要我们给出我们想要跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。\n\n\n\n- 关于reverse()：https://yiyibooks.cn/xx/Django_1.11.6/ref/urlresolvers.html#django.urls.reverse\n    + reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)[source]\n    + 例如，给定以下url：\n    ```\n    from news import views\n\n    url(r'^archive/$', views.archive, name='news-archive')\n\n    ```\n\n    + 可以使用以下任一操作来反转URL：\n    ```\n    # using the named URL\n    reverse('news-archive')\n\n\n\n    # passing a callable object\n    # (This is discouraged because you can't reverse namespaced views this way.),提倡用上面的方式\n    from news import views\n    reverse(views.archive)\n\n    ```\n\n    + 如果网址接受参数，您可以在args中传递参数。 像这样：\n    ```\n    from django.urls import reverse\n\n    def myview(request):\n        return HttpResponseRedirect(reverse('arch-summary', args=[1945]))\n\n    ```\n\n    + 您也可以传递kwargs而不是args。 像这样：\n    ```\n    >>> reverse('admin:app_list', kwargs={'app_label': 'auth'})\n    '/admin/auth/'\n    ```","source":"_posts/Django-基础篇3.md","raw":"---\ntitle: Django-基础篇3-视图与模板\ndate: 2018-08-30 00:10:49\ntags: Django\n---\n\n\n每个视图函数只负责处理两件事中的一件：返回一个包含所请求页面内容的 HttpResponse对象，或抛出一个诸如Http404异常。\n\n- 视图中使用模板：\n    ```\n    polls/views.py\n\n    from django.http import HttpResponse\n    from django.template import loader\n    from .models import Question\n    def index(request):\n        latest_question_list = Question.objects.order_by('-pub_date')[:5]\n        template = loader.get_template('polls/index.html')\n        context = {\n            'latest_question_list': latest_question_list,\n        }\n        return HttpResponse(template.render(context, request))\n\n\n    ```\n\n\n- 快捷方式：render()\n    + Django的快捷函数:https://yiyibooks.cn/xx/Django_1.11.6/topics/http/shortcuts.html#django.shortcuts.render\n    + render()函数将请求对象作为它的第一个参数，模板的名字作为它的第二个参数，一个字典作为它可选的第三个参数。 <font color=\"\">它返回一个HttpResponse对象，含有用给定的context 渲染后的模板。</font>\n\n\n- 抛出404异常\n    + 现在，让我们处理Question 详细页面的视图 —— 显示Question内容的页面： 下面是该视图：\n    + 如果没有找到所请求ID的Question，这个视图引发一个Http404异常。\n    ```\n    polls/views.py\n\n    from django.http import Http404\n    from django.shortcuts import render\n    from .models import Question\n    # ...\n    def detail(request, question_id):\n        try:\n            question = Question.objects.get(pk=question_id)\n        except Question.DoesNotExist:\n            raise Http404(\"Question does not exist\")\n        return render(request, 'polls/detail.html', {'question': question})\n\n\n    ```\n\n- 一个快捷方式：get_object_or_404() \n    + 一种常见的习惯是使用get()并在对象不存在时引发Http404。 Django为此提供一个快捷方式。 下面是重写后的detail()视图：\n    ```\n    polls/views.py\n\n    from django.shortcuts import get_object_or_404, render\n    from .models import Question\n    # ...\n    def detail(request, question_id):\n        question = get_object_or_404(Question, pk=question_id)\n        return render(request, 'polls/detail.html', {'question': question})\n\n    ```\n    + get_object_or_404() 函数将一个Django模型作为它的第一个参数，任意数量的关键字参数作为它的第二个参数，它会将这些关键字参数传递给模型管理器中的get() 函数。 如果对象不存在，它就引发一个 Http404异常。\n    + 还有一个get_list_or_404()函数，它的工作方式类似get_object_or_404() —— 差别在于它使用filter()而不是get()。 如果列表为空则引发Http404。\n\n\n\n- 移除模板中的硬编码\n    + 原来：\n    ```\n     <li><a href=\"/polls/{{ question.id }}/\">{{ question.question_text }}</a></li>\n\n    ```\n\n    + 修改后：\n    ```\n    <li><a href=\"{% url 'detail' question.id %}\">{{ question.question_text }}</a></li>\n\n\n    # the 'name' value as called by the {% url %} template tag\n    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n\n    ```\n\n    + 好处：\n        * 如果你想把polls应用中detail视图的URL改成其它样子比如polls/specifics/12/，就可以不必在该模板（或者多个模板）中修改它，只需要修改polls/urls.py：\n        ```\n        # added the word 'specifics'\n        url(r'^specifics/(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n        ```\n\n\n- 命名空间URL名称\n    + 在polls/urls.py文件中，继续添加app_name来设置应用程序命名空间：\n    ```\n    polls/urls.py\n\n    from django.conf.urls import url\n    from . import views\n    app_name = 'polls'\n    urlpatterns = [\n        url(r'^$', views.index, name='index'),\n        url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),\n        url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),\n        url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),\n    ]\n\n    ```\n\n    + 现在将你的模板polls/index.html由：\n    ```\n    polls/templates/polls/index.html\n    <li><a href=\"{% url 'detail' question.id %}\">{{ question.question_text }}</a></li>\n\n\n    修改为指向具有命名空间的详细视图：\n    polls/templates/polls/index.html\n    <li><a href=\"{% url 'polls:detail' question.id %}\">{{ question.question_text }}</a></li>\n\n    ```\n\n- 一个vote()函数的模拟实现\n    ```\n    polls/views.py\n\n    from django.shortcuts import get_object_or_404, render\n    from django.http import HttpResponseRedirect, HttpResponse\n    from django.urls import reverse\n    from .models import Choice, Question\n    # ...\n    def vote(request, question_id):\n        question = get_object_or_404(Question, pk=question_id)\n        try:\n            selected_choice = question.choice_set.get(pk=request.POST['choice'])\n        except (KeyError, Choice.DoesNotExist):\n            # 重新显示该问题的表单\n            return render(request, 'polls/detail.html', {\n                'question': question,\n                'error_message': \"You didn't select a choice.\",\n            })\n        else:\n            selected_choice.votes += 1\n            selected_choice.save()\n            # 始终在成功处理 POST 数据后返回一个 HttpResponseRedirect ，\n            # （合并上句） 这样可以防止用户点击“后退”按钮时数据被发送两次。\n            # （合并至上一句）\n            return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))\n\n\n    ```\n\n    + request.POST 是一个类似字典的对象，让你可以通过关键字的名字获取提交的数据。\n    + 如果在POST数据中没有提供request.POST['choice']，choice将引发一个KeyError。 上面的代码检查KeyError，如果没有给出choice将重新显示Question表单和一个错误信息。\n    + 异常参考：https://docs.python.org/3/library/exceptions.html\n    + 在增加Choice的得票数之后，<font color=\"red\">代码返回一个 HttpResponseRedirect而不是常用的HttpResponse。 HttpResponseRedirect只接收一个参数：用户将要被重定向的URL</font>\n    + 在这个例子中，我们在HttpResponseRedirect的构造函数中使用reverse()函数。 这个函数避免了我们在视图函数中硬编码URL。 它需要我们给出我们想要跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。\n\n\n\n- 关于reverse()：https://yiyibooks.cn/xx/Django_1.11.6/ref/urlresolvers.html#django.urls.reverse\n    + reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)[source]\n    + 例如，给定以下url：\n    ```\n    from news import views\n\n    url(r'^archive/$', views.archive, name='news-archive')\n\n    ```\n\n    + 可以使用以下任一操作来反转URL：\n    ```\n    # using the named URL\n    reverse('news-archive')\n\n\n\n    # passing a callable object\n    # (This is discouraged because you can't reverse namespaced views this way.),提倡用上面的方式\n    from news import views\n    reverse(views.archive)\n\n    ```\n\n    + 如果网址接受参数，您可以在args中传递参数。 像这样：\n    ```\n    from django.urls import reverse\n\n    def myview(request):\n        return HttpResponseRedirect(reverse('arch-summary', args=[1945]))\n\n    ```\n\n    + 您也可以传递kwargs而不是args。 像这样：\n    ```\n    >>> reverse('admin:app_list', kwargs={'app_label': 'auth'})\n    '/admin/auth/'\n    ```","slug":"Django-基础篇3","published":1,"updated":"2018-09-04T15:19:22.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkcz50004pstf9tti8132","content":"<p>每个视图函数只负责处理两件事中的一件：返回一个包含所请求页面内容的 HttpResponse对象，或抛出一个诸如Http404异常。</p>\n<ul>\n<li><p>视图中使用模板：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.template <span class=\"keyword\">import</span> loader</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Question</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    latest_question_list = Question.objects.order_by(<span class=\"string\">'-pub_date'</span>)[:<span class=\"number\">5</span>]</span><br><span class=\"line\">    template = loader.get_template(<span class=\"string\">'polls/index.html'</span>)</span><br><span class=\"line\">    context = &#123;</span><br><span class=\"line\">        <span class=\"string\">'latest_question_list'</span>: latest_question_list,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>快捷方式：render()</p>\n<ul>\n<li>Django的快捷函数:<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/topics/http/shortcuts.html#django.shortcuts.render\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/topics/http/shortcuts.html#django.shortcuts.render</a></li>\n<li>render()函数将请求对象作为它的第一个参数，模板的名字作为它的第二个参数，一个字典作为它可选的第三个参数。 <font color=\"\">它返回一个HttpResponse对象，含有用给定的context 渲染后的模板。</font></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>抛出404异常</p>\n<ul>\n<li>现在，让我们处理Question 详细页面的视图 —— 显示Question内容的页面： 下面是该视图：</li>\n<li>如果没有找到所请求ID的Question，这个视图引发一个Http404异常。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> Http404</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> render</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Question</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detail</span><span class=\"params\">(request, question_id)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        question = Question.objects.get(pk=question_id)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Question.DoesNotExist:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> Http404(<span class=\"string\">\"Question does not exist\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render(request, <span class=\"string\">'polls/detail.html'</span>, &#123;<span class=\"string\">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>一个快捷方式：get_object_or_404() </p>\n<ul>\n<li><p>一种常见的习惯是使用get()并在对象不存在时引发Http404。 Django为此提供一个快捷方式。 下面是重写后的detail()视图：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> get_object_or_404, render</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Question</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detail</span><span class=\"params\">(request, question_id)</span>:</span></span><br><span class=\"line\">    question = get_object_or_404(Question, pk=question_id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render(request, <span class=\"string\">'polls/detail.html'</span>, &#123;<span class=\"string\">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>get_object_or_404() 函数将一个Django模型作为它的第一个参数，任意数量的关键字参数作为它的第二个参数，它会将这些关键字参数传递给模型管理器中的get() 函数。 如果对象不存在，它就引发一个 Http404异常。</p>\n</li>\n<li>还有一个get_list_or_404()函数，它的工作方式类似get_object_or_404() —— 差别在于它使用filter()而不是get()。 如果列表为空则引发Http404。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>移除模板中的硬编码</p>\n<ul>\n<li><p>原来：</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/polls/</span></span></span><span class=\"template-variable\">&#123;&#123; question.id &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">/\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改后：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt;&lt;a href=<span class=\"string\">\"&#123;% url 'detail' question.id %&#125;\"</span>&gt;&#123;&#123; question.question_text &#125;&#125;&lt;<span class=\"regexp\">/a&gt;&lt;/</span>li&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># the 'name' value as called by the &#123;% url %&#125; template tag</span></span><br><span class=\"line\">url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/$'</span>, views.detail, name=<span class=\"string\">'detail'</span>),</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>好处：</p>\n<ul>\n<li>如果你想把polls应用中detail视图的URL改成其它样子比如polls/specifics/12/，就可以不必在该模板（或者多个模板）中修改它，只需要修改polls/urls.py：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># added the word 'specifics'</span></span><br><span class=\"line\">url(<span class=\"string\">r'^specifics/(?P&lt;question_id&gt;[0-9]+)/$'</span>, views.detail, name=<span class=\"string\">'detail'</span>),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>命名空间URL名称</p>\n<ul>\n<li><p>在polls/urls.py文件中，继续添加app_name来设置应用程序命名空间：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/urls.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.conf.urls <span class=\"keyword\">import</span> url</span><br><span class=\"line\"><span class=\"keyword\">from</span> . <span class=\"keyword\">import</span> views</span><br><span class=\"line\">app_name = <span class=\"string\">'polls'</span></span><br><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'^$'</span>, views.index, name=<span class=\"string\">'index'</span>),</span><br><span class=\"line\">    url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/$'</span>, views.detail, name=<span class=\"string\">'detail'</span>),</span><br><span class=\"line\">    url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/results/$'</span>, views.results, name=<span class=\"string\">'results'</span>),</span><br><span class=\"line\">    url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/vote/$'</span>, views.vote, name=<span class=\"string\">'vote'</span>),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在将你的模板polls/index.html由：</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\">polls/templates/polls/index.html</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"</span></span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">url</span></span> 'detail' question.id %&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">修改为指向具有命名空间的详细视图：</span></span><br><span class=\"line\"><span class=\"xml\">polls/templates/polls/index.html</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"</span></span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">url</span></span> 'polls:detail' question.id %&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>一个vote()函数的模拟实现</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> get_object_or_404, render</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect, HttpResponse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.urls <span class=\"keyword\">import</span> reverse</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Choice, Question</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">vote</span><span class=\"params\">(request, question_id)</span>:</span></span><br><span class=\"line\">    question = get_object_or_404(Question, pk=question_id)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        selected_choice = question.choice_set.get(pk=request.POST[<span class=\"string\">'choice'</span>])</span><br><span class=\"line\">    <span class=\"keyword\">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class=\"line\">        <span class=\"comment\"># 重新显示该问题的表单</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> render(request, <span class=\"string\">'polls/detail.html'</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">'question'</span>: question,</span><br><span class=\"line\">            <span class=\"string\">'error_message'</span>: <span class=\"string\">\"You didn't select a choice.\"</span>,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        selected_choice.votes += <span class=\"number\">1</span></span><br><span class=\"line\">        selected_choice.save()</span><br><span class=\"line\">        <span class=\"comment\"># 始终在成功处理 POST 数据后返回一个 HttpResponseRedirect ，</span></span><br><span class=\"line\">        <span class=\"comment\"># （合并上句） 这样可以防止用户点击“后退”按钮时数据被发送两次。</span></span><br><span class=\"line\">        <span class=\"comment\"># （合并至上一句）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'polls:results'</span>, args=(question.id,)))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>request.POST 是一个类似字典的对象，让你可以通过关键字的名字获取提交的数据。</li>\n<li>如果在POST数据中没有提供request.POST[‘choice’]，choice将引发一个KeyError。 上面的代码检查KeyError，如果没有给出choice将重新显示Question表单和一个错误信息。</li>\n<li>异常参考：<a href=\"https://docs.python.org/3/library/exceptions.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3/library/exceptions.html</a></li>\n<li>在增加Choice的得票数之后，<font color=\"red\">代码返回一个 HttpResponseRedirect而不是常用的HttpResponse。 HttpResponseRedirect只接收一个参数：用户将要被重定向的URL</font></li>\n<li>在这个例子中，我们在HttpResponseRedirect的构造函数中使用reverse()函数。 这个函数避免了我们在视图函数中硬编码URL。 它需要我们给出我们想要跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>关于reverse()：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/urlresolvers.html#django.urls.reverse\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/urlresolvers.html#django.urls.reverse</a></p>\n<ul>\n<li>reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)[source]</li>\n<li><p>例如，给定以下url：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> news <span class=\"keyword\">import</span> views</span><br><span class=\"line\"></span><br><span class=\"line\">url(<span class=\"string\">r'^archive/$'</span>, views.archive, name=<span class=\"string\">'news-archive'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以使用以下任一操作来反转URL：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># using the named URL</span></span><br><span class=\"line\"><span class=\"built_in\">reverse</span>('news-archive')</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># passing a callable object</span></span><br><span class=\"line\"><span class=\"comment\"># (This is discouraged because you can't reverse namespaced views this way.),提倡用上面的方式</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> news import views</span><br><span class=\"line\"><span class=\"built_in\">reverse</span>(views.archive)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果网址接受参数，您可以在args中传递参数。 像这样：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.urls <span class=\"keyword\">import</span> <span class=\"keyword\">reverse</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> myview(request):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponseRedirect(<span class=\"keyword\">reverse</span>(<span class=\"string\">'arch-summary'</span>, args=[<span class=\"number\">1945</span>]))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>您也可以传递kwargs而不是args。 像这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; reverse(<span class=\"string\">'admin:app_list'</span>, kwargs=&#123;<span class=\"string\">'app_label'</span>: <span class=\"string\">'auth'</span>&#125;)</span><br><span class=\"line\"><span class=\"string\">'/admin/auth/'</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>每个视图函数只负责处理两件事中的一件：返回一个包含所请求页面内容的 HttpResponse对象，或抛出一个诸如Http404异常。</p>\n<ul>\n<li><p>视图中使用模板：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.template <span class=\"keyword\">import</span> loader</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Question</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    latest_question_list = Question.objects.order_by(<span class=\"string\">'-pub_date'</span>)[:<span class=\"number\">5</span>]</span><br><span class=\"line\">    template = loader.get_template(<span class=\"string\">'polls/index.html'</span>)</span><br><span class=\"line\">    context = &#123;</span><br><span class=\"line\">        <span class=\"string\">'latest_question_list'</span>: latest_question_list,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>快捷方式：render()</p>\n<ul>\n<li>Django的快捷函数:<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/topics/http/shortcuts.html#django.shortcuts.render\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/topics/http/shortcuts.html#django.shortcuts.render</a></li>\n<li>render()函数将请求对象作为它的第一个参数，模板的名字作为它的第二个参数，一个字典作为它可选的第三个参数。 <font color=\"\">它返回一个HttpResponse对象，含有用给定的context 渲染后的模板。</font></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>抛出404异常</p>\n<ul>\n<li>现在，让我们处理Question 详细页面的视图 —— 显示Question内容的页面： 下面是该视图：</li>\n<li>如果没有找到所请求ID的Question，这个视图引发一个Http404异常。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> Http404</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> render</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Question</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detail</span><span class=\"params\">(request, question_id)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        question = Question.objects.get(pk=question_id)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Question.DoesNotExist:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> Http404(<span class=\"string\">\"Question does not exist\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render(request, <span class=\"string\">'polls/detail.html'</span>, &#123;<span class=\"string\">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>一个快捷方式：get_object_or_404() </p>\n<ul>\n<li><p>一种常见的习惯是使用get()并在对象不存在时引发Http404。 Django为此提供一个快捷方式。 下面是重写后的detail()视图：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> get_object_or_404, render</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Question</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detail</span><span class=\"params\">(request, question_id)</span>:</span></span><br><span class=\"line\">    question = get_object_or_404(Question, pk=question_id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render(request, <span class=\"string\">'polls/detail.html'</span>, &#123;<span class=\"string\">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>get_object_or_404() 函数将一个Django模型作为它的第一个参数，任意数量的关键字参数作为它的第二个参数，它会将这些关键字参数传递给模型管理器中的get() 函数。 如果对象不存在，它就引发一个 Http404异常。</p>\n</li>\n<li>还有一个get_list_or_404()函数，它的工作方式类似get_object_or_404() —— 差别在于它使用filter()而不是get()。 如果列表为空则引发Http404。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>移除模板中的硬编码</p>\n<ul>\n<li><p>原来：</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/polls/</span></span></span><span class=\"template-variable\">&#123;&#123; question.id &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">/\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改后：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt;&lt;a href=<span class=\"string\">\"&#123;% url 'detail' question.id %&#125;\"</span>&gt;&#123;&#123; question.question_text &#125;&#125;&lt;<span class=\"regexp\">/a&gt;&lt;/</span>li&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># the 'name' value as called by the &#123;% url %&#125; template tag</span></span><br><span class=\"line\">url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/$'</span>, views.detail, name=<span class=\"string\">'detail'</span>),</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>好处：</p>\n<ul>\n<li>如果你想把polls应用中detail视图的URL改成其它样子比如polls/specifics/12/，就可以不必在该模板（或者多个模板）中修改它，只需要修改polls/urls.py：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># added the word 'specifics'</span></span><br><span class=\"line\">url(<span class=\"string\">r'^specifics/(?P&lt;question_id&gt;[0-9]+)/$'</span>, views.detail, name=<span class=\"string\">'detail'</span>),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>命名空间URL名称</p>\n<ul>\n<li><p>在polls/urls.py文件中，继续添加app_name来设置应用程序命名空间：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/urls.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.conf.urls <span class=\"keyword\">import</span> url</span><br><span class=\"line\"><span class=\"keyword\">from</span> . <span class=\"keyword\">import</span> views</span><br><span class=\"line\">app_name = <span class=\"string\">'polls'</span></span><br><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'^$'</span>, views.index, name=<span class=\"string\">'index'</span>),</span><br><span class=\"line\">    url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/$'</span>, views.detail, name=<span class=\"string\">'detail'</span>),</span><br><span class=\"line\">    url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/results/$'</span>, views.results, name=<span class=\"string\">'results'</span>),</span><br><span class=\"line\">    url(<span class=\"string\">r'^(?P&lt;question_id&gt;[0-9]+)/vote/$'</span>, views.vote, name=<span class=\"string\">'vote'</span>),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在将你的模板polls/index.html由：</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\">polls/templates/polls/index.html</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"</span></span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">url</span></span> 'detail' question.id %&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">修改为指向具有命名空间的详细视图：</span></span><br><span class=\"line\"><span class=\"xml\">polls/templates/polls/index.html</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"</span></span></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">url</span></span> 'polls:detail' question.id %&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; question.question_text &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>一个vote()函数的模拟实现</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">polls/views.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> get_object_or_404, render</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect, HttpResponse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.urls <span class=\"keyword\">import</span> reverse</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> Choice, Question</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">vote</span><span class=\"params\">(request, question_id)</span>:</span></span><br><span class=\"line\">    question = get_object_or_404(Question, pk=question_id)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        selected_choice = question.choice_set.get(pk=request.POST[<span class=\"string\">'choice'</span>])</span><br><span class=\"line\">    <span class=\"keyword\">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class=\"line\">        <span class=\"comment\"># 重新显示该问题的表单</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> render(request, <span class=\"string\">'polls/detail.html'</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">'question'</span>: question,</span><br><span class=\"line\">            <span class=\"string\">'error_message'</span>: <span class=\"string\">\"You didn't select a choice.\"</span>,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        selected_choice.votes += <span class=\"number\">1</span></span><br><span class=\"line\">        selected_choice.save()</span><br><span class=\"line\">        <span class=\"comment\"># 始终在成功处理 POST 数据后返回一个 HttpResponseRedirect ，</span></span><br><span class=\"line\">        <span class=\"comment\"># （合并上句） 这样可以防止用户点击“后退”按钮时数据被发送两次。</span></span><br><span class=\"line\">        <span class=\"comment\"># （合并至上一句）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'polls:results'</span>, args=(question.id,)))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>request.POST 是一个类似字典的对象，让你可以通过关键字的名字获取提交的数据。</li>\n<li>如果在POST数据中没有提供request.POST[‘choice’]，choice将引发一个KeyError。 上面的代码检查KeyError，如果没有给出choice将重新显示Question表单和一个错误信息。</li>\n<li>异常参考：<a href=\"https://docs.python.org/3/library/exceptions.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3/library/exceptions.html</a></li>\n<li>在增加Choice的得票数之后，<font color=\"red\">代码返回一个 HttpResponseRedirect而不是常用的HttpResponse。 HttpResponseRedirect只接收一个参数：用户将要被重定向的URL</font></li>\n<li>在这个例子中，我们在HttpResponseRedirect的构造函数中使用reverse()函数。 这个函数避免了我们在视图函数中硬编码URL。 它需要我们给出我们想要跳转的视图的名字和该视图所对应的URL模式中需要给该视图提供的参数。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>关于reverse()：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/urlresolvers.html#django.urls.reverse\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/urlresolvers.html#django.urls.reverse</a></p>\n<ul>\n<li>reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)[source]</li>\n<li><p>例如，给定以下url：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> news <span class=\"keyword\">import</span> views</span><br><span class=\"line\"></span><br><span class=\"line\">url(<span class=\"string\">r'^archive/$'</span>, views.archive, name=<span class=\"string\">'news-archive'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以使用以下任一操作来反转URL：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># using the named URL</span></span><br><span class=\"line\"><span class=\"built_in\">reverse</span>('news-archive')</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># passing a callable object</span></span><br><span class=\"line\"><span class=\"comment\"># (This is discouraged because you can't reverse namespaced views this way.),提倡用上面的方式</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> news import views</span><br><span class=\"line\"><span class=\"built_in\">reverse</span>(views.archive)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果网址接受参数，您可以在args中传递参数。 像这样：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.urls <span class=\"keyword\">import</span> <span class=\"keyword\">reverse</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> myview(request):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponseRedirect(<span class=\"keyword\">reverse</span>(<span class=\"string\">'arch-summary'</span>, args=[<span class=\"number\">1945</span>]))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>您也可以传递kwargs而不是args。 像这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; reverse(<span class=\"string\">'admin:app_list'</span>, kwargs=&#123;<span class=\"string\">'app_label'</span>: <span class=\"string\">'auth'</span>&#125;)</span><br><span class=\"line\"><span class=\"string\">'/admin/auth/'</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Django-基础篇4","date":"2018-08-29T16:13:27.000Z","_content":"\n\n#### 模板","source":"_posts/Django-基础篇4.md","raw":"---\ntitle: Django-基础篇4\ndate: 2018-08-30 00:13:27\ntags: Django\n---\n\n\n#### 模板","slug":"Django-基础篇4","published":1,"updated":"2018-09-04T16:19:06.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkcz70006pstfbuf71c3p","content":"<h4 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h4>"},{"title":"Linux命令1-常用基本命令","date":"2018-07-21T16:00:00.000Z","toc":true,"_content":"\n### 1. 命令的使用方法  \n　　command  [-options][parameter1] ...　  \n　　说明：  \n　　command：命令名,相应功能的英文单词或单词的缩写\n　　[-options]：选项,可用来对命令进行控制，也可以省略  \n　　[]代表可选 parameter1 …：传给命令的参数（可以是零个，一个，或多个）\n<!--more-->　　\n\n　　栗子：  \n　　　　ls会列出当前工作目录的内容（文件或文件夹，就跟在GUI中打开一个文件夹看到的内容一样）\n　　　　{% qnimg ls.png %}\n\n### 2. 查看帮助文档\n#### 2-1 --help\n　　有时候我们不知道一个命令该怎么用的时候，我们可以通过帮助文档来查看帮助信息\n\n　　栗子：  \n　　　　ls  --help  \n　　　　{% qnimg help.png %}\n\n#### 2-2 man\n　　man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明\n　　该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。\n\n　　man中各个section意义如下：  \n　　　　1. Standard commands（标准命令）  \n　　　　2. System calls（系统调用，如open,write）  \n　　　　3. Library functions（库函数，如printf,fopen）  \n　　　　4. Special devices（设备文件的说明，/dev下各种设备）  \n　　　　5. File formats（文件格式，如passwd）  \n　　　　6. Games and toys（游戏和娱乐）　　　　\n　　　　7. Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII码；environ全局变量）  \n　　　　8. Administrative Commands（管理员命令，如ifconfig）\n　　　\n　　　\n\n　　栗子：  \n　　　　man ls   \n　　　　{% qnimg man.png %}\n　\n\n　　man是按照手册的章节号的顺序进行搜索的。  \n　　man设置了如下的功能键：  \n　　{% qnimg key.png %}\n\n\n### 3. 自动补全  \n　　在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令\n\n### 4. 历史命令  \n　　当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来\n","source":"_posts/Linux命令1-常用基本命令.md","raw":"---\ntitle: Linux命令1-常用基本命令\ndate: 2018-07-22 \ntags: Linux\ntoc: true\n---\n\n### 1. 命令的使用方法  \n　　command  [-options][parameter1] ...　  \n　　说明：  \n　　command：命令名,相应功能的英文单词或单词的缩写\n　　[-options]：选项,可用来对命令进行控制，也可以省略  \n　　[]代表可选 parameter1 …：传给命令的参数（可以是零个，一个，或多个）\n<!--more-->　　\n\n　　栗子：  \n　　　　ls会列出当前工作目录的内容（文件或文件夹，就跟在GUI中打开一个文件夹看到的内容一样）\n　　　　{% qnimg ls.png %}\n\n### 2. 查看帮助文档\n#### 2-1 --help\n　　有时候我们不知道一个命令该怎么用的时候，我们可以通过帮助文档来查看帮助信息\n\n　　栗子：  \n　　　　ls  --help  \n　　　　{% qnimg help.png %}\n\n#### 2-2 man\n　　man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明\n　　该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。\n\n　　man中各个section意义如下：  \n　　　　1. Standard commands（标准命令）  \n　　　　2. System calls（系统调用，如open,write）  \n　　　　3. Library functions（库函数，如printf,fopen）  \n　　　　4. Special devices（设备文件的说明，/dev下各种设备）  \n　　　　5. File formats（文件格式，如passwd）  \n　　　　6. Games and toys（游戏和娱乐）　　　　\n　　　　7. Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII码；environ全局变量）  \n　　　　8. Administrative Commands（管理员命令，如ifconfig）\n　　　\n　　　\n\n　　栗子：  \n　　　　man ls   \n　　　　{% qnimg man.png %}\n　\n\n　　man是按照手册的章节号的顺序进行搜索的。  \n　　man设置了如下的功能键：  \n　　{% qnimg key.png %}\n\n\n### 3. 自动补全  \n　　在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令\n\n### 4. 历史命令  \n　　当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来\n","slug":"Linux命令1-常用基本命令","published":1,"updated":"2018-08-22T16:09:02.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkcz90008pstf95jcrh3u","content":"<h3 id=\"1-命令的使用方法\"><a href=\"#1-命令的使用方法\" class=\"headerlink\" title=\"1. 命令的使用方法\"></a>1. 命令的使用方法</h3><p>　　command  [-options][parameter1] …　<br>　　说明：<br>　　command：命令名,相应功能的英文单词或单词的缩写<br>　　[-options]：选项,可用来对命令进行控制，也可以省略<br>　　[]代表可选 parameter1 …：传给命令的参数（可以是零个，一个，或多个）<br><a id=\"more\"></a>　　</p>\n<p>　　栗子：<br>　　　　ls会列出当前工作目录的内容（文件或文件夹，就跟在GUI中打开一个文件夹看到的内容一样）<br>　　　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ls.png\"></p>\n<h3 id=\"2-查看帮助文档\"><a href=\"#2-查看帮助文档\" class=\"headerlink\" title=\"2. 查看帮助文档\"></a>2. 查看帮助文档</h3><h4 id=\"2-1-–help\"><a href=\"#2-1-–help\" class=\"headerlink\" title=\"2-1 –help\"></a>2-1 –help</h4><p>　　有时候我们不知道一个命令该怎么用的时候，我们可以通过帮助文档来查看帮助信息</p>\n<p>　　栗子：<br>　　　　ls  –help<br>　　　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/help.png\"></p>\n<h4 id=\"2-2-man\"><a href=\"#2-2-man\" class=\"headerlink\" title=\"2-2 man\"></a>2-2 man</h4><p>　　man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明<br>　　该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。</p>\n<p>　　man中各个section意义如下：<br>　　　　1. Standard commands（标准命令）<br>　　　　2. System calls（系统调用，如open,write）<br>　　　　3. Library functions（库函数，如printf,fopen）<br>　　　　4. Special devices（设备文件的说明，/dev下各种设备）<br>　　　　5. File formats（文件格式，如passwd）<br>　　　　6. Games and toys（游戏和娱乐）　　　　<br>　　　　7. Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII码；environ全局变量）<br>　　　　8. Administrative Commands（管理员命令，如ifconfig）\n　　　\n　　　</p>\n<p>　　栗子：<br>　　　　man ls<br>　　　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/man.png\">\n　</p>\n<p>　　man是按照手册的章节号的顺序进行搜索的。<br>　　man设置了如下的功能键：<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/key.png\"></p>\n<h3 id=\"3-自动补全\"><a href=\"#3-自动补全\" class=\"headerlink\" title=\"3. 自动补全\"></a>3. 自动补全</h3><p>　　在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令</p>\n<h3 id=\"4-历史命令\"><a href=\"#4-历史命令\" class=\"headerlink\" title=\"4. 历史命令\"></a>4. 历史命令</h3><p>　　当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-命令的使用方法\"><a href=\"#1-命令的使用方法\" class=\"headerlink\" title=\"1. 命令的使用方法\"></a>1. 命令的使用方法</h3><p>　　command  [-options][parameter1] …　<br>　　说明：<br>　　command：命令名,相应功能的英文单词或单词的缩写<br>　　[-options]：选项,可用来对命令进行控制，也可以省略<br>　　[]代表可选 parameter1 …：传给命令的参数（可以是零个，一个，或多个）<br>","more":"</p>\n<p>　　栗子：<br>　　　　ls会列出当前工作目录的内容（文件或文件夹，就跟在GUI中打开一个文件夹看到的内容一样）<br>　　　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ls.png\"></p>\n<h3 id=\"2-查看帮助文档\"><a href=\"#2-查看帮助文档\" class=\"headerlink\" title=\"2. 查看帮助文档\"></a>2. 查看帮助文档</h3><h4 id=\"2-1-–help\"><a href=\"#2-1-–help\" class=\"headerlink\" title=\"2-1 –help\"></a>2-1 –help</h4><p>　　有时候我们不知道一个命令该怎么用的时候，我们可以通过帮助文档来查看帮助信息</p>\n<p>　　栗子：<br>　　　　ls  –help<br>　　　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/help.png\"></p>\n<h4 id=\"2-2-man\"><a href=\"#2-2-man\" class=\"headerlink\" title=\"2-2 man\"></a>2-2 man</h4><p>　　man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明<br>　　该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。</p>\n<p>　　man中各个section意义如下：<br>　　　　1. Standard commands（标准命令）<br>　　　　2. System calls（系统调用，如open,write）<br>　　　　3. Library functions（库函数，如printf,fopen）<br>　　　　4. Special devices（设备文件的说明，/dev下各种设备）<br>　　　　5. File formats（文件格式，如passwd）<br>　　　　6. Games and toys（游戏和娱乐）　　　　<br>　　　　7. Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII码；environ全局变量）<br>　　　　8. Administrative Commands（管理员命令，如ifconfig）\n　　　\n　　　</p>\n<p>　　栗子：<br>　　　　man ls<br>　　　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/man.png\">\n　</p>\n<p>　　man是按照手册的章节号的顺序进行搜索的。<br>　　man设置了如下的功能键：<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/key.png\"></p>\n<h3 id=\"3-自动补全\"><a href=\"#3-自动补全\" class=\"headerlink\" title=\"3. 自动补全\"></a>3. 自动补全</h3><p>　　在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令</p>\n<h3 id=\"4-历史命令\"><a href=\"#4-历史命令\" class=\"headerlink\" title=\"4. 历史命令\"></a>4. 历史命令</h3><p>　　当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来</p>"},{"title":"Linux命令2-常用系统管理","date":"2018-08-18T07:35:57.000Z","toc":true,"_content":"\n### 查看进程信息:ps  \n　　进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。　　\n　　ps命令可以查看进程的详细状况，常用选项如下(选项可以不加“-”)：  \n<!--more-->\n　　**选项**    **含义**   \n　　-a  显示终端上的所有进程，包括其他用户的进程  \n　　-u  显示进程的详细状态  \n　　-x  显示没有控制终端的进程  \n　　-w  显示加宽，以便显示更多的信息  \n　　-r  只显示正在运行的进程  \n\n　　栗子：  \n　　{% qnimg ps.png %}\n　　\n\n\n### 动态显示进程:top\n　　top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。  　　可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。　　\n　　在top命令执行后，可以按下按键得到对显示的结果进行排序：  \n\n　　\n　　**按键**    **含义**  \n　　M   根据内存使用量来排序  \n　　P   根据CPU占有率来排序  \n　　T   根据进程运行时间的长短来排序  \n　　U   可以根据后面输入的用户名来筛选进程  \n　　K   可以根据后面输入的PID来杀死进程。  \n　　q   退出  \n　　h   获得帮助  \n\n　　\n\n\n### 终止进程：kill\n　　kill命令指定进程号的进程，需要配合 ps 使用。 \n\n　　使用格式：  \n　　kill [-signal] pid  \n　　信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。  \n　　（有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束：） \n\n　　kill 9133 ：（9133 为应用程序所对应的进程号） \n\n　　\n\n### 查看或配置网卡信息：ifconfig\n　　ifconfig，它会显示所有网卡的信息   \n　　栗子:  \n　　{% qnimg ifconfig.png %}\n\n### 测试远程主机连通性：ping\n　　栗子:  \n　　{% qnimg ping.png %}\n　　\n　　\n\n","source":"_posts/Linux命令2-系统管理.md","raw":"---\ntitle: Linux命令2-常用系统管理\ndate: 2018-08-18 15:35:57\ntags: Linux\ntoc: true\n---\n\n### 查看进程信息:ps  \n　　进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。　　\n　　ps命令可以查看进程的详细状况，常用选项如下(选项可以不加“-”)：  \n<!--more-->\n　　**选项**    **含义**   \n　　-a  显示终端上的所有进程，包括其他用户的进程  \n　　-u  显示进程的详细状态  \n　　-x  显示没有控制终端的进程  \n　　-w  显示加宽，以便显示更多的信息  \n　　-r  只显示正在运行的进程  \n\n　　栗子：  \n　　{% qnimg ps.png %}\n　　\n\n\n### 动态显示进程:top\n　　top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。  　　可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。　　\n　　在top命令执行后，可以按下按键得到对显示的结果进行排序：  \n\n　　\n　　**按键**    **含义**  \n　　M   根据内存使用量来排序  \n　　P   根据CPU占有率来排序  \n　　T   根据进程运行时间的长短来排序  \n　　U   可以根据后面输入的用户名来筛选进程  \n　　K   可以根据后面输入的PID来杀死进程。  \n　　q   退出  \n　　h   获得帮助  \n\n　　\n\n\n### 终止进程：kill\n　　kill命令指定进程号的进程，需要配合 ps 使用。 \n\n　　使用格式：  \n　　kill [-signal] pid  \n　　信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。  \n　　（有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束：） \n\n　　kill 9133 ：（9133 为应用程序所对应的进程号） \n\n　　\n\n### 查看或配置网卡信息：ifconfig\n　　ifconfig，它会显示所有网卡的信息   \n　　栗子:  \n　　{% qnimg ifconfig.png %}\n\n### 测试远程主机连通性：ping\n　　栗子:  \n　　{% qnimg ping.png %}\n　　\n　　\n\n","slug":"Linux命令2-系统管理","published":1,"updated":"2018-08-22T16:09:13.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkczb000apstfbi7jl9e8","content":"<h3 id=\"查看进程信息-ps\"><a href=\"#查看进程信息-ps\" class=\"headerlink\" title=\"查看进程信息:ps\"></a>查看进程信息:ps</h3><p>　　进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。　　<br>　　ps命令可以查看进程的详细状况，常用选项如下(选项可以不加“-”)：<br><a id=\"more\"></a><br>　　<strong>选项</strong>    <strong>含义</strong><br>　　-a  显示终端上的所有进程，包括其他用户的进程<br>　　-u  显示进程的详细状态<br>　　-x  显示没有控制终端的进程<br>　　-w  显示加宽，以便显示更多的信息<br>　　-r  只显示正在运行的进程  </p>\n<p>　　栗子：<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ps.png\">\n　　</p>\n<h3 id=\"动态显示进程-top\"><a href=\"#动态显示进程-top\" class=\"headerlink\" title=\"动态显示进程:top\"></a>动态显示进程:top</h3><p>　　top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。  　　可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。　　<br>　　在top命令执行后，可以按下按键得到对显示的结果进行排序：  </p>\n<p>　　<br>　　<strong>按键</strong>    <strong>含义</strong><br>　　M   根据内存使用量来排序<br>　　P   根据CPU占有率来排序<br>　　T   根据进程运行时间的长短来排序<br>　　U   可以根据后面输入的用户名来筛选进程<br>　　K   可以根据后面输入的PID来杀死进程。<br>　　q   退出<br>　　h   获得帮助  </p>\n<p>　　</p>\n<h3 id=\"终止进程：kill\"><a href=\"#终止进程：kill\" class=\"headerlink\" title=\"终止进程：kill\"></a>终止进程：kill</h3><p>　　kill命令指定进程号的进程，需要配合 ps 使用。 </p>\n<p>　　使用格式：<br>　　kill [-signal] pid<br>　　信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。<br>　　（有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束：） </p>\n<p>　　kill 9133 ：（9133 为应用程序所对应的进程号） </p>\n<p>　　</p>\n<h3 id=\"查看或配置网卡信息：ifconfig\"><a href=\"#查看或配置网卡信息：ifconfig\" class=\"headerlink\" title=\"查看或配置网卡信息：ifconfig\"></a>查看或配置网卡信息：ifconfig</h3><p>　　ifconfig，它会显示所有网卡的信息<br>　　栗子:<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ifconfig.png\"></p>\n<h3 id=\"测试远程主机连通性：ping\"><a href=\"#测试远程主机连通性：ping\" class=\"headerlink\" title=\"测试远程主机连通性：ping\"></a>测试远程主机连通性：ping</h3><p>　　栗子:<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ping.png\">\n　　\n　　</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"查看进程信息-ps\"><a href=\"#查看进程信息-ps\" class=\"headerlink\" title=\"查看进程信息:ps\"></a>查看进程信息:ps</h3><p>　　进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。　　<br>　　ps命令可以查看进程的详细状况，常用选项如下(选项可以不加“-”)：<br>","more":"<br>　　<strong>选项</strong>    <strong>含义</strong><br>　　-a  显示终端上的所有进程，包括其他用户的进程<br>　　-u  显示进程的详细状态<br>　　-x  显示没有控制终端的进程<br>　　-w  显示加宽，以便显示更多的信息<br>　　-r  只显示正在运行的进程  </p>\n<p>　　栗子：<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ps.png\">\n　　</p>\n<h3 id=\"动态显示进程-top\"><a href=\"#动态显示进程-top\" class=\"headerlink\" title=\"动态显示进程:top\"></a>动态显示进程:top</h3><p>　　top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。  　　可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。　　<br>　　在top命令执行后，可以按下按键得到对显示的结果进行排序：  </p>\n<p>　　<br>　　<strong>按键</strong>    <strong>含义</strong><br>　　M   根据内存使用量来排序<br>　　P   根据CPU占有率来排序<br>　　T   根据进程运行时间的长短来排序<br>　　U   可以根据后面输入的用户名来筛选进程<br>　　K   可以根据后面输入的PID来杀死进程。<br>　　q   退出<br>　　h   获得帮助  </p>\n<p>　　</p>\n<h3 id=\"终止进程：kill\"><a href=\"#终止进程：kill\" class=\"headerlink\" title=\"终止进程：kill\"></a>终止进程：kill</h3><p>　　kill命令指定进程号的进程，需要配合 ps 使用。 </p>\n<p>　　使用格式：<br>　　kill [-signal] pid<br>　　信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。<br>　　（有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束：） </p>\n<p>　　kill 9133 ：（9133 为应用程序所对应的进程号） </p>\n<p>　　</p>\n<h3 id=\"查看或配置网卡信息：ifconfig\"><a href=\"#查看或配置网卡信息：ifconfig\" class=\"headerlink\" title=\"查看或配置网卡信息：ifconfig\"></a>查看或配置网卡信息：ifconfig</h3><p>　　ifconfig，它会显示所有网卡的信息<br>　　栗子:<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ifconfig.png\"></p>\n<h3 id=\"测试远程主机连通性：ping\"><a href=\"#测试远程主机连通性：ping\" class=\"headerlink\" title=\"测试远程主机连通性：ping\"></a>测试远程主机连通性：ping</h3><p>　　栗子:<br>　　<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/ping.png\">\n　　\n　　</p>"},{"title":"Django-基础篇2","date":"2018-08-28T13:57:28.000Z","_content":"\n\n### 常用命令：\n\n- 创建项目：\n    + django-admin startproject 项目名称\n    \n- 创建应用：\n    + python manage.py startapp test  \n\n<!--more-->\n- 生成迁移文件：\n    + python manage.py makemigrations\n\n- 执行迁移：\n    + python manage.py migrate （app名）  \n\n\n- 创建管理员:\n    + python manage.py createsuperuser\n\n- 启动服务器:\n    + python manage.py runserver\n\n\n- 查看虚拟环境中安装了哪些包 \n    + pip list\n    \n- 虚拟环境中的包收集到requirements.txt中\n    +  pip freeze >requirement.txt \n\n- 安装requirements.txt中的包\n     + pip install -r requirements.txt\n\n\n\n\n\n### 模型（Model）\n\n\n#### 字段类型和字段操作\n- 可通过右侧目录查看具体字段类型和字段操作用法\n- 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html \n \n{% qnimg field_types.png %}  {% qnimg field_options.png %}  {% qnimg other_fields.png %}\n\n- 模型的 Meta 选项  \n    + 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html  \n    \n    {% qnimg meta.png %}  \n\n#### model的使用\n- 文档：https://yiyibooks.cn/xx/Django_1.11.6/topics/db/queries.html\n- 后面栗子中用到的模型：\n    ```\n    from django.db import models\n\n    class Blog(models.Model):\n        name = models.CharField(max_length=100)\n        tagline = models.TextField()\n\n        def __str__(self):              # __unicode__ on Python 2\n            return self.name\n\n\n    class Author(models.Model):\n        name = models.CharField(max_length=200)\n        email = models.EmailField()\n\n        def __str__(self):              # __unicode__ on Python 2\n            return self.name\n\n\n    class Entry(models.Model):\n        blog = models.ForeignKey(Blog)#Blog 和 Entry 是一对多的关系\n        headline = models.CharField(max_length=255)\n        body_text = models.TextField()\n        pub_date = models.DateField()\n        mod_date = models.DateField()\n        authors = models.ManyToManyField(Author)#Author 和 Entry 是多对多的关系\n        n_comments = models.IntegerField()\n        n_pingbacks = models.IntegerField()\n        rating = models.IntegerField()\n\n        def __str__(self):              # __unicode__ on Python 2\n            return self.headline\n \n    ```\n\n- 创建对象\n    + 一个模型类代表数据库中的一个表，一个模型类的实例代表这个数据库表中的一条特定的记录。\n    + 使用关键字参数实例化模型实例来创建一个对象，然后调用save() 把它保存到数据库中。\n    + 例子：\n    ```\n    >>> from blog.models import Blog\n    \n    >>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')\n    >>> b.save()\n    \n    ```\n    + 上面的代码在背后执行了SQL 的INSERT 语句。 <font color=red>在你显式调用save()之前，Django 不会访问数据库。</font>\n\n- 保存ForeignKey和ManyToManyField字段\n    + 更新ForeignKey 字段的方式和保存普通字段相同 — 只要把一个正确类型的对象赋值给该字段。 下面的例子更新一个Entry实例entry的blog属性，假设Entry和Blog已经有正确的实例保存在数据库中（所以我们可以像下面这样获取它们）：  \n    ``` \n    from blog.models import Blog, Entry   \n\n    entry = Entry.objects.get(pk=1)    \n    cheese_blog = Blog.objects.get(name=\"Cheddar Talk\")    \n    entry.blog = cheese_blog    \n    entry.save() \n\n    ```\n\n    + 更新ManyToManyField 的方式有一些不同 — <font color=\"red\">需要使用字段的add()方法来增加关联关系的一条记录。 </font>>下面这个例子向entry对象添加Author类的实例joe：\n    ```\n    >>> from blog.models import Author\n    >>> joe = Author.objects.create(name=\"Joe\")\n    >>> entry.authors.add(joe)\n    \n    ```\n\n\n    + 为了在一条语句中，向ManyToManyField添加多条记录，可以在调用add()方法时传入多个参数，像这样：\n    ```\n    >>> john = Author.objects.create(name=\"John\")\n    >>> paul = Author.objects.create(name=\"Paul\")\n    >>> george = Author.objects.create(name=\"George\")\n    >>> ringo = Author.objects.create(name=\"Ringo\")\n    >>> entry.authors.add(john, paul, george, ringo) \n\n    ```\n\n\n- 检索对象\n    + 通过模型中的Manager构造一个QuerySet，来从你的数据库中获取对象。\n    + <font color=\"red\">  QuerySet表示从数据库中取出来的对象的集合。 </font>它可以含有零个、一个或者多个过滤器。 过滤器基于所给的参数限制查询的结果。 从SQL 的角度来看，QuerySet和SELECT 语句等价，过滤器是像WHERE 和LIMIT 一样的限制子句。\n    + 你可以从模型的Manager那里取得QuerySet。 每个模型都至少有一个Manager，<font color=\"red\">它默认命名为objects。  </font>\n    + 对于一个模型来说，Manager是QuerySets的主要来源。 例如， Blog.objects.all() 返回一个QuerySet，<font color=\"red\">这个QuerySet包含数据库中所有Blog对象，即Blog表中所有的记录.</font>\n\n- 关于QuerySet及其他QuerySet方法\n    + 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.query.QuerySet  \n\n    {% qnimg QuerySet1.png %}  {% qnimg QuerySet2.png %} {% qnimg QuerySet3.png %} {% qnimg QuerySet4.png %} \n\n- 检索所有对象\n    + 获取一个表中所有对象的最简单的方式是全部获取。 可以使用Manager的all() 方法：\n    ```\n    >>> all_entries = Entry.objects.all()\n    ```\n    + all()方法返回包含数据库中所有对象的一个QuerySet。\n\n\n\n- 使用过滤器检索特定对象\n    + all() 方法返回了一个包含数据库表中所有记录QuerySet。 但在通常情况下，你往往想要获取的是完整数据集的一个子集。\n\n    + 要创建这样一个子集，你需要在原始的的QuerySet上增加一些过滤条件。 QuerySet两个最普遍的途径是：\n        * filter(**kwargs)\n            * 返回一个新的QuerySet，它包含满足查询参数的对象。\n        * exclude(**kwargs)\n            * 返回一个新的QuerySet，它包含不满足查询参数的对象。\n        \n        * 举个例子，要获取年份为2006的所有文章的QuerySet，可以使用filter()方法：\n        ```\n        Entry.objects.filter(pub_date__year=2006)\n        ```\n        * 利用默认的管理器，它相当于：\n        ```\n        Entry.objects.all().filter(pub_date__year=2006)\n        ```\n\n    + 链式过滤器\n        * QuerySet的筛选结果本身还是QuerySet，所以可以将筛选语句链接在一起。 像这样：\n        ```\n        >>> Entry.objects.filter(\n        ...     headline__startswith='What'\n        ... ).exclude(\n        ...     pub_date__gte=datetime.date.today()\n        ... ).filter(\n        ...     pub_date__gte=datetime(2005, 1, 30)\n        ... )\n        ```\n    + QuerySet是惰性的\n        * QuerySets 是惰性执行的,创建QuerySet不会带来任何数据库的访问。一般来说，只有在“请求”QuerySet 的结果时才会到数据库中去获取它们。 当你确实需要结果时，QuerySet 通过访问数据库来求值。\n\n\n- 使用get()检索单个对象\n    + <font color=\"red\">filter() 始终给你一个QuerySet，</font>即使只有一个对象满足查询条件 —— 这种情况下，QuerySet将只包含一个元素。\n    + 如果你知道只有一个对象满足你的查询，你可以使用Manager的get() 方法，<font color=\"red\">它直接返回该对象：</font>\n    ```\n    >>> one_entry = Entry.objects.get(pk=1)\n    ```\n\n    + 注意，使用get() 和使用filter() 的切片[0] 有一点区别。 如果没有结果满足查询，get() 将引发一个DoesNotExist 异常。 这个异常是正在查询的模型类的一个属性 —— 所以在上面的代码中，如果没有主键(pk) 为1 的Entry对象，Django 将引发一个Entry.DoesNotExist 。\n\n    + 类似地，如果有多条记录满足get() 的查询条件，Django 也将报错。 这种情况将引发MultipleObjectsReturned，它同样是模型类自身的一个属性。\n\n- 限制QuerySet\n    + 可以使用Python 的切片语法来限制QuerySet记录的数目 。 它等同于SQL 的OFFSET 和LIMIT 子句。\n    + 例如:\n    ```\n    >>> Entry.objects.all()[:5]\n    >>> Entry.objects.all()[5:10]\n    >>> Entry.objects.all()[:10:2]\n    >>> Entry.objects.order_by('headline')[0]\n    ```\n    \n- 字段查找\n    + 字段查询是指如何指定SQL WHERE 子句的内容。 它们通过QuerySet方法filter()、exclude() 和 get() 的关键字参数指定。\n    + <font color=\"red\">查询的关键字参数的基本形式是field__lookuptype=value。 （中间是两个下划线）。</font>  像这样：\n    ```\n    >>> Entry.objects.filter(pub_date__lte='2006-01-01')\n    >>> 翻译成SQL（大体）是：\n    >>> SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';\n    ```\n    + 查询条件中指定的字段必须是模型字段的名称。 但有一个例外，<font color=\"red\">对于ForeignKey你可以使用字段名加上_id 后缀。 在这种情况下，该参数的值应该是外键的原始值</font> 。 像这样：\n    ```\n    >>> Entry.objects.filter(blog_id=4)\n    ```\n    + 如果你传递的是一个不合法的参数，查询函数将引发 TypeError。\n    \n    + 数据库API支持大约二十种查找类型；参考文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#field-lookups ；<font color=\"red\">搜索定位：Field查找。</font>\n\n-  <font color=\"red\">跨关联关系的查询</font>\n    + Django 提供一种强大而又直观的方式来“处理”查询中的关联关系，它在后台自动帮你处理JOIN。 <font color=\"red\">若要跨越关联关系，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段</font>：\n    + 下面这个例子获取所有Blog 的name 为'Beatles Blog' 的Entry 对象：\n    ```\n    >>> Entry.objects.filter(blog__name='Beatles Blog')\n    ```\n\n    + 它还可以反向工作。 若要引用一个“反向”的关系，只需要使用该模型的小写的名称。\n    下面的示例获取所有的Blog 对象，它们至少有一个Entry 的headline包含'Lennon'：\n    ```\n    >>> Blog.objects.filter(entry__headline__contains='Lennon')\n    ```\n    + 如果你在多个关联关系过滤而且其中某个中介模型没有满足过滤条件的值，Django 将把它当做一个空的（所有的值都为NULL）但是合法的对象。 这意味着不会有错误引发。 例如，在下面的过滤器中：\n    ```\n    Blog.objects.filter(entry__authors__name='Lennon')\n\n    ```\n\n    + （如果有一个相关联的Author 模型），如果没有author与entry关联，那么它将当作其没有name，而不会因为没有author 引发一个错误。 通常，这就是你想要的。 唯一可能让你困惑的是当你使用isnull 的时候。 因此：\n    ```\n    Blog.objects.filter(entry__authors__name__isnull=True)\n    ```\n    + 返回的Blog对象包括author的name为空的对象，以及entry上的author为空的对象。 如果你不需要后者，你可以这样写：\n    ```\n    Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)\n\n    ```\n\n\n- 跨越多值的关联关系\n    + 选择所有包含 <font color=\"red\">同时满足两个条件的entry的blog</font> ，这两个条件是headline 包含Lennon 和发表时间是2008 <font color=\"red\">（同一个entry 满足两个条件）</font> ，我们的代码是：\n    ```\n    Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)\n    ```\n    + 要选择所有这样的blog，有一个entry的headline包含“Lennon”和有一个entry发表时间是2008，我们将这样编写：\n    ```\n   Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)\n    ```\n    + 假设这里有一个blog拥有一条包含'Lennon'的entries条目和一条来自2008的entries条目,但是没有一条来自2008并且包含\"Lennon\"的entries条目。 第一个查询不会返回任何blog，第二个查询将会返回一个blog。\n\n    + 在第二个例子中， 第一个filter限定查询集为所有与headline包含“Lennon”的entry关联的blog。 第二个filter进一步限定查询集中的blog，这些blog关联的entry 的发表时间是2008。 第二个filter 过滤出来的entry 与第一个filter 过滤出来的entry 可能相同也可能不同。 <font color=\"red\">我们用每个filter语句过滤的是Blog，而不是Entry。</font>\n\n    + 跨越多值关系的filter() 查询的行为，与exclude() 实现的不同。 单个exclude() 调用中的条件不必引用同一个记录。\n    + 例如，下面的查询将<font color=\"red\">排除两种 </font>entry的blog，headline中包含“Lennon”的entry和在2008年发布的entry：\n    ```\n    Blog.objects.exclude(\n        entry__headline__contains='Lennon',\n        entry__pub_date__year=2008,\n    )\n    ```\n\n    + 然而，这与使用filter() 的行为不同，它不是排除<font color=\"red\">同时满足</font>两个条件的Entry。 为了实现这点，即选择的Blog中不包含在2008年发布且healine 中带有“Lennon” 的Entry，你需要编写两个查询：\n    ```\n    Blog.objects.exclude(\n        entry__in=Entry.objects.filter(\n            headline__contains='Lennon',\n            pub_date__year=2008,\n        ),\n    )\n    ```\n\n- 过滤器可以引用模型的字段\n    + 查询表达式\n        * 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/expressions.html#django.db.models.F  \n        {%qnimg F.png %}\n\n    + 将模型的一个字段与同一个模型的另外一个字段进行比较\n    + Django 提供F表达式 来允许这样的比较。 <font color=\"red\">F() 返回的实例用作查询内部对模型字段的引用。</font> 这些引用可以用于查询的filter 中来<font color=\"red\">比较相同模型实例上</font>不同字段之间值的比较。\n    ```\n    例如，为了查找comments 数目多于pingbacks 的Entry，我们将构造一个F() 对象来引用pingback 数目，并在查询中使用该F() 对象：\n\n    >>> from django.db.models import F\n    >>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))\n\n    ```\n\n    + Django 支持对F() 对象使用加法、减法、乘法、除法、取模以及幂计算等算术操作，两个操作数可以都是常数和其它F() 对象。\n    ```\n    为了查找comments 数目比pingbacks 两倍还要多的Entry，我们将查询修改为：\n    >>> Entry.objects.filter(n_comments__gt=F('n_pingbacks') * 2)\n  \n    为了查询rating 比pingback 和comment 数目总和要小的Entry，我们将这样查询：\n    >>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))\n    ```\n\n    + 你还可以在F() 对象中使用双下划线标记来跨越关联关系。 带有双下划线的F() 对象将引入任何需要的join 操作以访问关联的对象。 \n    \n    ```\n    例如，如要获取author 的名字与blog 名字相同的Entry，我们可以这样查询：\n    >>> Entry.objects.filter(authors__name=F('blog__name'))\n    ```\n\n    + 对于date 和date/time 字段，你可以给它们加上或减去一个timedelta 对象。 \n    ```\n    下面的例子将返回发布超过3天后被修改的所有Entry：\n    >>> from datetime import timedelta\n    >>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))\n    ```\n\n\n- pk查找快捷方式\n    + 为了方便，Django 提供一个查询快捷方式pk ，它表示“primary key” 的意思\n    ```\n    在示例Blog模型中，主键pk是id字段，所以这三个语句是等价的：\n\n    >>> Blog.objects.get(id__exact=14) # Explicit form\n    >>> Blog.objects.get(id=14) # __exact is implied\n    >>> Blog.objects.get(pk=14) # pk implies id__exact\n    \n    ```\n\n\n    + pk的使用并不限于__ exact查询 - 任何查询词都可以与pk组合来执行查询一个模型的primary key：\n    ```\n    # Get blogs entries with id 1, 4 and 7\n    >>> Blog.objects.filter(pk__in=[1,4,7])\n\n    # Get all blog entries with id > 14\n    >>> Blog.objects.filter(pk__gt=14)\n\n    ```\n\n    + pk查询在join 中也可以工作。 例如，下面三个语句是等同的：\n    ```\n    >>> Entry.objects.filter(blog__id__exact=3) # Explicit form\n    >>> Entry.objects.filter(blog__id=3)        # __exact is implied\n    >>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact\n    \n    ```\n\n- 在LIKE语句中转义百分号和下划线\n    + 与endswith SQL 语句等同的字段查询（LIKE、 istartswith、isendswith、isexact、 LIKE、startswith 和contains）将自动转义在contains 语句中使用的两个特殊的字符 —— 百分号和下划线。 （在LIKE 语句中，百分号通配符表示多个字符，下划线通配符表示单个字符）。\n\n    ```\n    例如，要获取包含一个百分号的所有的Entry，只需要像其它任何字符一样使用百分号：\n    >>> Entry.objects.filter(headline__contains='%')\n \n    Django照顾你的引用；生成的SQL将如下所示：\n    SELECT ... WHERE headline LIKE '%\\%%';\n\n    ```\n\n\n- 缓存和QuerySet\n    + 每个QuerySet都包含一个缓存来最小化对数据库的访问。 理解它是如何工作的将让你编写最高效的代码。\n    + 在一个新创建的QuerySet中，缓存为空。 首次对QuerySet进行求值 —— 同时发生数据库查询 ——Django <font color=\"red\">将保存查询的结果到QuerySet的缓存中并返回明确请求的结果</font>（例如，如果正在迭代QuerySet，则返回下一个结果）。 接下来对该QuerySet 的求值将重用缓存的结果。\n    \n    ```\n    请牢记这个缓存行为，因为对QuerySet使用不当的话，它会坑你的。 例如，下面的语句创建两个QuerySet，对它们求值，然后扔掉它们：\n    >>> print([e.headline for e in Entry.objects.all()])\n    >>> print([e.pub_date for e in Entry.objects.all()])\n    这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。 同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Entry被添加进来或删除掉。\n\n\n\n    为了避免这个问题，只需保存QuerySet并重新使用它：\n\n    >>> queryset = Entry.objects.all()\n    >>> print([p.headline for p in queryset]) # Evaluate the query set.\n    >>> print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.\n    ```\n\n\n- 当QuerySet不缓存\n    + 查询集不会永远缓存它们的结果。 当只对查询集的部分进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。 特别地，这意味着使用切片或索引来limiting the queryset将不会填充缓存。\n\n    ```\n    例如，重复获取查询集对象中一个特定的索引将每次都查询数据库：\n    >>> queryset = Entry.objects.all()\n    >>> print(queryset[5]) # Queries the database\n    >>> print(queryset[5]) # Queries the database again\n    \n    然而，如果已经对全部查询集求值过，则将检查缓存：\n    >>> queryset = Entry.objects.all()\n    >>> [entry for entry in queryset] # Queries the database\n    >>> print(queryset[5]) # Uses cache\n    >>> print(queryset[5]) # Uses cache\n  \n\n    下面是一些其它例子，它们会使得全部的查询集被求值并填充到缓存中：\n    >>> [entry for entry in queryset]\n    >>> bool(queryset)\n    >>> entry in queryset\n    >>> list(queryset)\n\n    ```\n\n\n- 使用Q对象进行复杂查找\n    + 在filter()中的关键字参数查询 — — 是“AND”的关系。 如果你需要执行更复杂的查询（例如OR 语句），你可以使用Q对象。\n    + Q object (django.db.models.Q) 对象用于封装一组关键字参数。 这些关键字参数就是上文“字段查询” 中所提及的那些。\n        * 文档： https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.Q  搜索：Q()对象\n    + Q对象可以使用&和|操作符组合起来。 当一个操作符在两个Q 对象上使用时，它产生一个新的Q 对象。\n\n    ```\n    例如，下面的语句产生一个\"question__startswith\" 对象，表示两个Q 查询的“OR” ：\n    Q(question__startswith='Who') | Q(question__startswith='What')\n\n\n    它等同于下面的SQL WHERE 子句：\n    WHERE question LIKE 'Who%' OR question LIKE 'What%'\n    ```\n    + 你可以组合& 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。 同时，~ 对象可以使用NOT 操作符取反，\n\n    ```\n    这允许组合正常的查询和取反(Q) 查询：\n    Q(question__startswith='Who') | ~Q(pub_date__year=2005)\n    ```\n\n    + 每个接受关键字参数的查询函数（例如filter()、exclude()、get()）都可以传递一个或多个Q 对象作为位置（不带名的）参数。 如果一个查询函数有多个Q 对象参数，这些参数的逻辑关系为“AND\"。 像这样：\n    ```\n    Poll.objects.get(\n        Q(question__startswith='Who'),\n        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\n    )\n\n\n\n    ...大致翻译成SQL：\n    SELECT * from polls WHERE question LIKE 'Who%'\n        AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')\n    ```\n\n    + 查询函数可以混合使用Q和关键字参数。 所有提供给查询函数的参数（关键字参数或Q 对象）都将\"AND”在一起。<font color=\"red\"> 但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 </font>\n    ```\n    像这样：\n    Poll.objects.get(\n        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),\n        question__startswith='Who',\n    )\n    ...将是一个有效的查询，相当于前面的例子；但：\n\n    # INVALID QUERY\n    Poll.objects.get(\n        question__startswith='Who',\n        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\n    )\n    ...不会有效\n\n    ```\n\n\n\n\n\n- 比较对象\n    + 为了比较两个模型实例，只需要使用标准的Python 比较操作符，即双等于符号：==。 在后台，它会比较两个模型主键的值。\n    ```\n    利用上面的Entry 示例，下面两个语句是等同的：\n    >>> some_entry == other_entry\n    >>> some_entry.id == other_entry.id\n   \n    \n    如果模型的主键不叫id，也没有问题。 比较将始终使用主键，无论它叫什么。 例如，如果模型的主键字段叫做name，下面的两条语句是等同的：\n    >>> some_obj == other_obj\n    >>> some_obj.name == other_obj.name\n\n    ```\n\n\n\n- 删除对象\n    + 删除方法，为了方便，就取名为delete()。 该方法立即删除对象，并返回一个字典，该字典包含着删除的对象数量和每个对象类型的删除次数。 例如：\n    ```\n    >>> e.delete()\n    (1, {'weblog.Entry': 1})\n    ```\n\n\n    + 你还可以批量删除对象。 每个QuerySet 都有一个delete() 方法，它将删除该QuerySet中的所有成员。\n    ```\n    例如，下面的语句删除pub_date 为2005 的所有Entry 对象：\n    >>> Entry.objects.filter(pub_date__year=2005).delete()\n    (5, {'webapp.Entry': 5})\n\n    ```\n\n    + 当Django 删除一个对象时，它默认使用SQL ON DELETE CASCADE 约束 —— 换句话讲，任何有外键指向要删除对象的对象将一起删除。 像这样：\n    ```\n    b = Blog.objects.get(pk=1)\n    # This will delete the Blog and all of its Entry objects.\n    b.delete()\n    ```\n    +  注意，delete()是唯一没有在Manager上暴露出来的QuerySet方法。 这是一个安全机制来防止你意外地请求Entry.objects.delete()，而删除所有 的条目。 <font color=\"red\">如果你确实想删除所有的对象，你必须明确地请求一个完全的查询集：</font>\n    ```\n      Entry.objects.all().delete()\n    ```\n\n- 一次更新多个对象  \n    + 有时你想为一个QuerySet中所有对象的某个字段都设置一个特定的值。 这时你可以使用update() 方法。 像这样：\n    ```\n    # Update all the headlines with pub_date in 2007\n    Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')\n    ```\n    + 你只可以对非关联字段和ForeignKey 字段使用这个方法。 若要更新一个非关联字段，只需提供一个新的常数值。 <font color=\"red\">若要更新ForeignKey 字段，需设置新的值为你想指向的新的模型实例</font>。 像这样：\n\n    ```\n    >>> b = Blog.objects.get(pk=1)\n    # Change every Entry so that it belongs to this Blog.\n    >>> Entry.objects.all().update(blog=b)\n    ```\n\n    + update() 方法会立即执行并返回查询匹配的行数（如果有些行已经具有新的值，返回的行数可能和被更新的行数不相等）。 正在更新的QuerySet的唯一限制是它只能访问一个数据库表：模型的主表。 <font color=\"red\">你可以根据关联的字段过滤，但是你只能更新模型主表中的列。</font> 例如：\n    ```\n    >>> b = Blog.objects.get(pk=1)\n    # Update all the headlines belonging to this Blog.\n    >>> Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')\n    ```\n    + 要注意update() 方法会直接转换成一个SQL 语句。 它是一个批量的直接更新操作。 它不会运行模型的save() 方法，或者发出pre_save 或 post_save信号（调用save()方法产生）或者查看auto_now 字段选项。 如果你想保存QuerySet中的每个条目并确保每个实例的save() 方法都被调用，你不需要使用任何特殊的函数来处理。 只需要迭代它们并调用save()：\n    ```\n    for item in my_queryset:\n        item.save()\n    ```\n\n    + 对update 的调用也可以使用F expressions 来根据模型中的一个字段更新另外一个字段。 这对于在当前值的基础上加上一个值特别有用。 例如，增加Blog 中每个Entry 的pingback 个数：\n    ```\n    >>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)\n    ```\n\n    + 然而，与filter 和exclude 子句中的F() 对象不同，<font color=\"red\">在update 中你不可以使用F() 对象引入join —— 你只可以引用正在更新的模型的字段</font>。 如果你尝试使用F()对象引入一个join，将引发一个FieldError：\n    ```\n    # This will raise a FieldError\n    >>> Entry.objects.update(headline=F('blog__name'))\n    ```\n\n\n- <font color=\"red\">一对多关系</font>  \n\n    + <font color=\"red\">正向查询：</font>\n    + 如果一个模型具有ForeignKey，那么该模型的实例将可以通过属性访问关联的（外部）对象。 例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> e.blog # Returns the related Blog object.\n    ```\n\n    + 你可以通过外键属性获取和设置。 和你预期的一样，对外键的修改不会保存到数据库中直至你调用save()。 例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> e.blog = some_blog\n    >>> e.save()\n    ```\n    + 如果ForeignKey 字段有NULL 设置（即它允许null=True 值），你可以分配None 来删除对应的关联性。  例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> e.blog = None\n    >>> e.save() # \"UPDATE blog_entry SET blog_id = NULL ...;\"\n    ```\n    + 一对多关联关系的前向访问在第一次访问关联的对象时被缓存。 以后对同一个对象的外键的访问都使用缓存。  例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> print(e.blog)  # Hits the database to retrieve the associated Blog.\n    >>> print(e.blog)  # Doesn't hit the database; uses cached version.\n    ```\n\n    + 注意select_related() QuerySet方法递归地预填充所有的一对多关系到缓存中。 例如：\n    ```\n    ```\n\n\n    + <font color=\"red\">反向查询</font>\n    + 如果模型有一个ForeignKey，那么该ForeignKey所指的模型实例可以通过一个Manager返回第一个模型的所有实例。 默认情况下，这个Manager的名字为FOO_set，其中FOO是源模型的小写名称。 该Manager返回QuerySets，可以用上一节提到的方式进行过滤和操作。例如：\n    ```\n    >>> b = Blog.objects.get(id=1)\n    >>> b.entry_set.all() # Returns all Entry objects related to Blog.\n\n    # b.entry_set is a Manager that returns QuerySets.\n    >>> b.entry_set.filter(headline__contains='Lennon')\n    >>> b.entry_set.count()\n    \n    ```\n\n    + 你可以在ForeignKey 定义时设置related_name 参数来覆盖FOO_set 的名称。 例如，如果Entry模型更改为blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name='entries')，上述示例代码如下所示：\n    ```\n    >>> b = Blog.objects.get(id=1)\n    >>> b.entries.all() # Returns all Entry objects related to Blog.\n\n    # b.entries is a Manager that returns QuerySets.\n    >>> b.entries.filter(headline__contains='Lennon')\n    >>> b.entries.count()\n    ```\n\n    + 处理关联对象其他方法\n        * https://yiyibooks.cn/xx/Django_1.11.6/ref/models/relations.html\n        * add（），create（），remove（），set（）\n\n    + <font color=\"red\">这一节中提到的每个”反向“操作都会立即对数据库产生作用。 每个添加、创建和删除操作都会立即并自动保存到数据库中。</font>\n\n\n- 多对多关系\n    + 多对多关系的两端都会自动获得访问另一端的API。 这些API 的工作方式与上面提到的“方向”一对多关系一样。\n    + 唯一的区别在于属性的命名：定义 ManyToManyField 的模型使用该字段的属性名称，而“反向”模型使用源模型的小写名称加上'_set' （和一对多关系一样）。\n    + 例如：\n    ```\n    e = Entry.objects.get(id=3)\n    e.authors.all() # Returns all Author objects for this Entry.\n    e.authors.count()\n    e.authors.filter(name__contains='John')\n\n    a = Author.objects.get(id=5)\n    a.entry_set.all() # Returns all Entry objects for this Author.\n\n    ```\n\n    + 类似ForeignKey，ManyToManyField 可以指定related_name。 在上面的例子中，如果entry_set 中的ManyToManyField 指定entries，那么Entry 实例将使用 related_name='entries' 属性而不是Author。\n\n\n- 一对一关系\n    + 一对一关系与多对一关系非常相似。 如果你在模型中定义一个OneToOneField，该模型的实例将可以通过该模型的一个简单属性访问关联的模型。\n    + 例如：\n    ```\n    class EntryDetail(models.Model):\n    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)\n    details = models.TextField()\n\n    ed = EntryDetail.objects.get(id=2)\n    ed.entry # Returns the related Entry object.\n    ```\n\n\n    + 在“反向”查询中有所不同。 一对一关系中的关联模型同样具有一个Manager对象，但是该Manager表示一个单一的对象而不是对象的集合：\n    ```\n    e = Entry.objects.get(id=2)\n    e.entrydetail # returns the related EntryDetail object\n\n    ```\n\n\n\n\n\n\n\n### url\n\n\n\n### 视图（View）\n\n\n\n\n\n\n### 模板（templates）\n\n\n\n\n\n\n### setting文件","source":"_posts/Django-基础篇2.md","raw":"---\ntitle: Django-基础篇2\ndate: 2018-08-28 21:57:28\ntags: Django\n---\n\n\n### 常用命令：\n\n- 创建项目：\n    + django-admin startproject 项目名称\n    \n- 创建应用：\n    + python manage.py startapp test  \n\n<!--more-->\n- 生成迁移文件：\n    + python manage.py makemigrations\n\n- 执行迁移：\n    + python manage.py migrate （app名）  \n\n\n- 创建管理员:\n    + python manage.py createsuperuser\n\n- 启动服务器:\n    + python manage.py runserver\n\n\n- 查看虚拟环境中安装了哪些包 \n    + pip list\n    \n- 虚拟环境中的包收集到requirements.txt中\n    +  pip freeze >requirement.txt \n\n- 安装requirements.txt中的包\n     + pip install -r requirements.txt\n\n\n\n\n\n### 模型（Model）\n\n\n#### 字段类型和字段操作\n- 可通过右侧目录查看具体字段类型和字段操作用法\n- 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html \n \n{% qnimg field_types.png %}  {% qnimg field_options.png %}  {% qnimg other_fields.png %}\n\n- 模型的 Meta 选项  \n    + 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html  \n    \n    {% qnimg meta.png %}  \n\n#### model的使用\n- 文档：https://yiyibooks.cn/xx/Django_1.11.6/topics/db/queries.html\n- 后面栗子中用到的模型：\n    ```\n    from django.db import models\n\n    class Blog(models.Model):\n        name = models.CharField(max_length=100)\n        tagline = models.TextField()\n\n        def __str__(self):              # __unicode__ on Python 2\n            return self.name\n\n\n    class Author(models.Model):\n        name = models.CharField(max_length=200)\n        email = models.EmailField()\n\n        def __str__(self):              # __unicode__ on Python 2\n            return self.name\n\n\n    class Entry(models.Model):\n        blog = models.ForeignKey(Blog)#Blog 和 Entry 是一对多的关系\n        headline = models.CharField(max_length=255)\n        body_text = models.TextField()\n        pub_date = models.DateField()\n        mod_date = models.DateField()\n        authors = models.ManyToManyField(Author)#Author 和 Entry 是多对多的关系\n        n_comments = models.IntegerField()\n        n_pingbacks = models.IntegerField()\n        rating = models.IntegerField()\n\n        def __str__(self):              # __unicode__ on Python 2\n            return self.headline\n \n    ```\n\n- 创建对象\n    + 一个模型类代表数据库中的一个表，一个模型类的实例代表这个数据库表中的一条特定的记录。\n    + 使用关键字参数实例化模型实例来创建一个对象，然后调用save() 把它保存到数据库中。\n    + 例子：\n    ```\n    >>> from blog.models import Blog\n    \n    >>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')\n    >>> b.save()\n    \n    ```\n    + 上面的代码在背后执行了SQL 的INSERT 语句。 <font color=red>在你显式调用save()之前，Django 不会访问数据库。</font>\n\n- 保存ForeignKey和ManyToManyField字段\n    + 更新ForeignKey 字段的方式和保存普通字段相同 — 只要把一个正确类型的对象赋值给该字段。 下面的例子更新一个Entry实例entry的blog属性，假设Entry和Blog已经有正确的实例保存在数据库中（所以我们可以像下面这样获取它们）：  \n    ``` \n    from blog.models import Blog, Entry   \n\n    entry = Entry.objects.get(pk=1)    \n    cheese_blog = Blog.objects.get(name=\"Cheddar Talk\")    \n    entry.blog = cheese_blog    \n    entry.save() \n\n    ```\n\n    + 更新ManyToManyField 的方式有一些不同 — <font color=\"red\">需要使用字段的add()方法来增加关联关系的一条记录。 </font>>下面这个例子向entry对象添加Author类的实例joe：\n    ```\n    >>> from blog.models import Author\n    >>> joe = Author.objects.create(name=\"Joe\")\n    >>> entry.authors.add(joe)\n    \n    ```\n\n\n    + 为了在一条语句中，向ManyToManyField添加多条记录，可以在调用add()方法时传入多个参数，像这样：\n    ```\n    >>> john = Author.objects.create(name=\"John\")\n    >>> paul = Author.objects.create(name=\"Paul\")\n    >>> george = Author.objects.create(name=\"George\")\n    >>> ringo = Author.objects.create(name=\"Ringo\")\n    >>> entry.authors.add(john, paul, george, ringo) \n\n    ```\n\n\n- 检索对象\n    + 通过模型中的Manager构造一个QuerySet，来从你的数据库中获取对象。\n    + <font color=\"red\">  QuerySet表示从数据库中取出来的对象的集合。 </font>它可以含有零个、一个或者多个过滤器。 过滤器基于所给的参数限制查询的结果。 从SQL 的角度来看，QuerySet和SELECT 语句等价，过滤器是像WHERE 和LIMIT 一样的限制子句。\n    + 你可以从模型的Manager那里取得QuerySet。 每个模型都至少有一个Manager，<font color=\"red\">它默认命名为objects。  </font>\n    + 对于一个模型来说，Manager是QuerySets的主要来源。 例如， Blog.objects.all() 返回一个QuerySet，<font color=\"red\">这个QuerySet包含数据库中所有Blog对象，即Blog表中所有的记录.</font>\n\n- 关于QuerySet及其他QuerySet方法\n    + 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.query.QuerySet  \n\n    {% qnimg QuerySet1.png %}  {% qnimg QuerySet2.png %} {% qnimg QuerySet3.png %} {% qnimg QuerySet4.png %} \n\n- 检索所有对象\n    + 获取一个表中所有对象的最简单的方式是全部获取。 可以使用Manager的all() 方法：\n    ```\n    >>> all_entries = Entry.objects.all()\n    ```\n    + all()方法返回包含数据库中所有对象的一个QuerySet。\n\n\n\n- 使用过滤器检索特定对象\n    + all() 方法返回了一个包含数据库表中所有记录QuerySet。 但在通常情况下，你往往想要获取的是完整数据集的一个子集。\n\n    + 要创建这样一个子集，你需要在原始的的QuerySet上增加一些过滤条件。 QuerySet两个最普遍的途径是：\n        * filter(**kwargs)\n            * 返回一个新的QuerySet，它包含满足查询参数的对象。\n        * exclude(**kwargs)\n            * 返回一个新的QuerySet，它包含不满足查询参数的对象。\n        \n        * 举个例子，要获取年份为2006的所有文章的QuerySet，可以使用filter()方法：\n        ```\n        Entry.objects.filter(pub_date__year=2006)\n        ```\n        * 利用默认的管理器，它相当于：\n        ```\n        Entry.objects.all().filter(pub_date__year=2006)\n        ```\n\n    + 链式过滤器\n        * QuerySet的筛选结果本身还是QuerySet，所以可以将筛选语句链接在一起。 像这样：\n        ```\n        >>> Entry.objects.filter(\n        ...     headline__startswith='What'\n        ... ).exclude(\n        ...     pub_date__gte=datetime.date.today()\n        ... ).filter(\n        ...     pub_date__gte=datetime(2005, 1, 30)\n        ... )\n        ```\n    + QuerySet是惰性的\n        * QuerySets 是惰性执行的,创建QuerySet不会带来任何数据库的访问。一般来说，只有在“请求”QuerySet 的结果时才会到数据库中去获取它们。 当你确实需要结果时，QuerySet 通过访问数据库来求值。\n\n\n- 使用get()检索单个对象\n    + <font color=\"red\">filter() 始终给你一个QuerySet，</font>即使只有一个对象满足查询条件 —— 这种情况下，QuerySet将只包含一个元素。\n    + 如果你知道只有一个对象满足你的查询，你可以使用Manager的get() 方法，<font color=\"red\">它直接返回该对象：</font>\n    ```\n    >>> one_entry = Entry.objects.get(pk=1)\n    ```\n\n    + 注意，使用get() 和使用filter() 的切片[0] 有一点区别。 如果没有结果满足查询，get() 将引发一个DoesNotExist 异常。 这个异常是正在查询的模型类的一个属性 —— 所以在上面的代码中，如果没有主键(pk) 为1 的Entry对象，Django 将引发一个Entry.DoesNotExist 。\n\n    + 类似地，如果有多条记录满足get() 的查询条件，Django 也将报错。 这种情况将引发MultipleObjectsReturned，它同样是模型类自身的一个属性。\n\n- 限制QuerySet\n    + 可以使用Python 的切片语法来限制QuerySet记录的数目 。 它等同于SQL 的OFFSET 和LIMIT 子句。\n    + 例如:\n    ```\n    >>> Entry.objects.all()[:5]\n    >>> Entry.objects.all()[5:10]\n    >>> Entry.objects.all()[:10:2]\n    >>> Entry.objects.order_by('headline')[0]\n    ```\n    \n- 字段查找\n    + 字段查询是指如何指定SQL WHERE 子句的内容。 它们通过QuerySet方法filter()、exclude() 和 get() 的关键字参数指定。\n    + <font color=\"red\">查询的关键字参数的基本形式是field__lookuptype=value。 （中间是两个下划线）。</font>  像这样：\n    ```\n    >>> Entry.objects.filter(pub_date__lte='2006-01-01')\n    >>> 翻译成SQL（大体）是：\n    >>> SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';\n    ```\n    + 查询条件中指定的字段必须是模型字段的名称。 但有一个例外，<font color=\"red\">对于ForeignKey你可以使用字段名加上_id 后缀。 在这种情况下，该参数的值应该是外键的原始值</font> 。 像这样：\n    ```\n    >>> Entry.objects.filter(blog_id=4)\n    ```\n    + 如果你传递的是一个不合法的参数，查询函数将引发 TypeError。\n    \n    + 数据库API支持大约二十种查找类型；参考文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#field-lookups ；<font color=\"red\">搜索定位：Field查找。</font>\n\n-  <font color=\"red\">跨关联关系的查询</font>\n    + Django 提供一种强大而又直观的方式来“处理”查询中的关联关系，它在后台自动帮你处理JOIN。 <font color=\"red\">若要跨越关联关系，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段</font>：\n    + 下面这个例子获取所有Blog 的name 为'Beatles Blog' 的Entry 对象：\n    ```\n    >>> Entry.objects.filter(blog__name='Beatles Blog')\n    ```\n\n    + 它还可以反向工作。 若要引用一个“反向”的关系，只需要使用该模型的小写的名称。\n    下面的示例获取所有的Blog 对象，它们至少有一个Entry 的headline包含'Lennon'：\n    ```\n    >>> Blog.objects.filter(entry__headline__contains='Lennon')\n    ```\n    + 如果你在多个关联关系过滤而且其中某个中介模型没有满足过滤条件的值，Django 将把它当做一个空的（所有的值都为NULL）但是合法的对象。 这意味着不会有错误引发。 例如，在下面的过滤器中：\n    ```\n    Blog.objects.filter(entry__authors__name='Lennon')\n\n    ```\n\n    + （如果有一个相关联的Author 模型），如果没有author与entry关联，那么它将当作其没有name，而不会因为没有author 引发一个错误。 通常，这就是你想要的。 唯一可能让你困惑的是当你使用isnull 的时候。 因此：\n    ```\n    Blog.objects.filter(entry__authors__name__isnull=True)\n    ```\n    + 返回的Blog对象包括author的name为空的对象，以及entry上的author为空的对象。 如果你不需要后者，你可以这样写：\n    ```\n    Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)\n\n    ```\n\n\n- 跨越多值的关联关系\n    + 选择所有包含 <font color=\"red\">同时满足两个条件的entry的blog</font> ，这两个条件是headline 包含Lennon 和发表时间是2008 <font color=\"red\">（同一个entry 满足两个条件）</font> ，我们的代码是：\n    ```\n    Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)\n    ```\n    + 要选择所有这样的blog，有一个entry的headline包含“Lennon”和有一个entry发表时间是2008，我们将这样编写：\n    ```\n   Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)\n    ```\n    + 假设这里有一个blog拥有一条包含'Lennon'的entries条目和一条来自2008的entries条目,但是没有一条来自2008并且包含\"Lennon\"的entries条目。 第一个查询不会返回任何blog，第二个查询将会返回一个blog。\n\n    + 在第二个例子中， 第一个filter限定查询集为所有与headline包含“Lennon”的entry关联的blog。 第二个filter进一步限定查询集中的blog，这些blog关联的entry 的发表时间是2008。 第二个filter 过滤出来的entry 与第一个filter 过滤出来的entry 可能相同也可能不同。 <font color=\"red\">我们用每个filter语句过滤的是Blog，而不是Entry。</font>\n\n    + 跨越多值关系的filter() 查询的行为，与exclude() 实现的不同。 单个exclude() 调用中的条件不必引用同一个记录。\n    + 例如，下面的查询将<font color=\"red\">排除两种 </font>entry的blog，headline中包含“Lennon”的entry和在2008年发布的entry：\n    ```\n    Blog.objects.exclude(\n        entry__headline__contains='Lennon',\n        entry__pub_date__year=2008,\n    )\n    ```\n\n    + 然而，这与使用filter() 的行为不同，它不是排除<font color=\"red\">同时满足</font>两个条件的Entry。 为了实现这点，即选择的Blog中不包含在2008年发布且healine 中带有“Lennon” 的Entry，你需要编写两个查询：\n    ```\n    Blog.objects.exclude(\n        entry__in=Entry.objects.filter(\n            headline__contains='Lennon',\n            pub_date__year=2008,\n        ),\n    )\n    ```\n\n- 过滤器可以引用模型的字段\n    + 查询表达式\n        * 文档：https://yiyibooks.cn/xx/Django_1.11.6/ref/models/expressions.html#django.db.models.F  \n        {%qnimg F.png %}\n\n    + 将模型的一个字段与同一个模型的另外一个字段进行比较\n    + Django 提供F表达式 来允许这样的比较。 <font color=\"red\">F() 返回的实例用作查询内部对模型字段的引用。</font> 这些引用可以用于查询的filter 中来<font color=\"red\">比较相同模型实例上</font>不同字段之间值的比较。\n    ```\n    例如，为了查找comments 数目多于pingbacks 的Entry，我们将构造一个F() 对象来引用pingback 数目，并在查询中使用该F() 对象：\n\n    >>> from django.db.models import F\n    >>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))\n\n    ```\n\n    + Django 支持对F() 对象使用加法、减法、乘法、除法、取模以及幂计算等算术操作，两个操作数可以都是常数和其它F() 对象。\n    ```\n    为了查找comments 数目比pingbacks 两倍还要多的Entry，我们将查询修改为：\n    >>> Entry.objects.filter(n_comments__gt=F('n_pingbacks') * 2)\n  \n    为了查询rating 比pingback 和comment 数目总和要小的Entry，我们将这样查询：\n    >>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))\n    ```\n\n    + 你还可以在F() 对象中使用双下划线标记来跨越关联关系。 带有双下划线的F() 对象将引入任何需要的join 操作以访问关联的对象。 \n    \n    ```\n    例如，如要获取author 的名字与blog 名字相同的Entry，我们可以这样查询：\n    >>> Entry.objects.filter(authors__name=F('blog__name'))\n    ```\n\n    + 对于date 和date/time 字段，你可以给它们加上或减去一个timedelta 对象。 \n    ```\n    下面的例子将返回发布超过3天后被修改的所有Entry：\n    >>> from datetime import timedelta\n    >>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))\n    ```\n\n\n- pk查找快捷方式\n    + 为了方便，Django 提供一个查询快捷方式pk ，它表示“primary key” 的意思\n    ```\n    在示例Blog模型中，主键pk是id字段，所以这三个语句是等价的：\n\n    >>> Blog.objects.get(id__exact=14) # Explicit form\n    >>> Blog.objects.get(id=14) # __exact is implied\n    >>> Blog.objects.get(pk=14) # pk implies id__exact\n    \n    ```\n\n\n    + pk的使用并不限于__ exact查询 - 任何查询词都可以与pk组合来执行查询一个模型的primary key：\n    ```\n    # Get blogs entries with id 1, 4 and 7\n    >>> Blog.objects.filter(pk__in=[1,4,7])\n\n    # Get all blog entries with id > 14\n    >>> Blog.objects.filter(pk__gt=14)\n\n    ```\n\n    + pk查询在join 中也可以工作。 例如，下面三个语句是等同的：\n    ```\n    >>> Entry.objects.filter(blog__id__exact=3) # Explicit form\n    >>> Entry.objects.filter(blog__id=3)        # __exact is implied\n    >>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact\n    \n    ```\n\n- 在LIKE语句中转义百分号和下划线\n    + 与endswith SQL 语句等同的字段查询（LIKE、 istartswith、isendswith、isexact、 LIKE、startswith 和contains）将自动转义在contains 语句中使用的两个特殊的字符 —— 百分号和下划线。 （在LIKE 语句中，百分号通配符表示多个字符，下划线通配符表示单个字符）。\n\n    ```\n    例如，要获取包含一个百分号的所有的Entry，只需要像其它任何字符一样使用百分号：\n    >>> Entry.objects.filter(headline__contains='%')\n \n    Django照顾你的引用；生成的SQL将如下所示：\n    SELECT ... WHERE headline LIKE '%\\%%';\n\n    ```\n\n\n- 缓存和QuerySet\n    + 每个QuerySet都包含一个缓存来最小化对数据库的访问。 理解它是如何工作的将让你编写最高效的代码。\n    + 在一个新创建的QuerySet中，缓存为空。 首次对QuerySet进行求值 —— 同时发生数据库查询 ——Django <font color=\"red\">将保存查询的结果到QuerySet的缓存中并返回明确请求的结果</font>（例如，如果正在迭代QuerySet，则返回下一个结果）。 接下来对该QuerySet 的求值将重用缓存的结果。\n    \n    ```\n    请牢记这个缓存行为，因为对QuerySet使用不当的话，它会坑你的。 例如，下面的语句创建两个QuerySet，对它们求值，然后扔掉它们：\n    >>> print([e.headline for e in Entry.objects.all()])\n    >>> print([e.pub_date for e in Entry.objects.all()])\n    这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。 同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Entry被添加进来或删除掉。\n\n\n\n    为了避免这个问题，只需保存QuerySet并重新使用它：\n\n    >>> queryset = Entry.objects.all()\n    >>> print([p.headline for p in queryset]) # Evaluate the query set.\n    >>> print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.\n    ```\n\n\n- 当QuerySet不缓存\n    + 查询集不会永远缓存它们的结果。 当只对查询集的部分进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。 特别地，这意味着使用切片或索引来limiting the queryset将不会填充缓存。\n\n    ```\n    例如，重复获取查询集对象中一个特定的索引将每次都查询数据库：\n    >>> queryset = Entry.objects.all()\n    >>> print(queryset[5]) # Queries the database\n    >>> print(queryset[5]) # Queries the database again\n    \n    然而，如果已经对全部查询集求值过，则将检查缓存：\n    >>> queryset = Entry.objects.all()\n    >>> [entry for entry in queryset] # Queries the database\n    >>> print(queryset[5]) # Uses cache\n    >>> print(queryset[5]) # Uses cache\n  \n\n    下面是一些其它例子，它们会使得全部的查询集被求值并填充到缓存中：\n    >>> [entry for entry in queryset]\n    >>> bool(queryset)\n    >>> entry in queryset\n    >>> list(queryset)\n\n    ```\n\n\n- 使用Q对象进行复杂查找\n    + 在filter()中的关键字参数查询 — — 是“AND”的关系。 如果你需要执行更复杂的查询（例如OR 语句），你可以使用Q对象。\n    + Q object (django.db.models.Q) 对象用于封装一组关键字参数。 这些关键字参数就是上文“字段查询” 中所提及的那些。\n        * 文档： https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.Q  搜索：Q()对象\n    + Q对象可以使用&和|操作符组合起来。 当一个操作符在两个Q 对象上使用时，它产生一个新的Q 对象。\n\n    ```\n    例如，下面的语句产生一个\"question__startswith\" 对象，表示两个Q 查询的“OR” ：\n    Q(question__startswith='Who') | Q(question__startswith='What')\n\n\n    它等同于下面的SQL WHERE 子句：\n    WHERE question LIKE 'Who%' OR question LIKE 'What%'\n    ```\n    + 你可以组合& 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。 同时，~ 对象可以使用NOT 操作符取反，\n\n    ```\n    这允许组合正常的查询和取反(Q) 查询：\n    Q(question__startswith='Who') | ~Q(pub_date__year=2005)\n    ```\n\n    + 每个接受关键字参数的查询函数（例如filter()、exclude()、get()）都可以传递一个或多个Q 对象作为位置（不带名的）参数。 如果一个查询函数有多个Q 对象参数，这些参数的逻辑关系为“AND\"。 像这样：\n    ```\n    Poll.objects.get(\n        Q(question__startswith='Who'),\n        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\n    )\n\n\n\n    ...大致翻译成SQL：\n    SELECT * from polls WHERE question LIKE 'Who%'\n        AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')\n    ```\n\n    + 查询函数可以混合使用Q和关键字参数。 所有提供给查询函数的参数（关键字参数或Q 对象）都将\"AND”在一起。<font color=\"red\"> 但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 </font>\n    ```\n    像这样：\n    Poll.objects.get(\n        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),\n        question__startswith='Who',\n    )\n    ...将是一个有效的查询，相当于前面的例子；但：\n\n    # INVALID QUERY\n    Poll.objects.get(\n        question__startswith='Who',\n        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\n    )\n    ...不会有效\n\n    ```\n\n\n\n\n\n- 比较对象\n    + 为了比较两个模型实例，只需要使用标准的Python 比较操作符，即双等于符号：==。 在后台，它会比较两个模型主键的值。\n    ```\n    利用上面的Entry 示例，下面两个语句是等同的：\n    >>> some_entry == other_entry\n    >>> some_entry.id == other_entry.id\n   \n    \n    如果模型的主键不叫id，也没有问题。 比较将始终使用主键，无论它叫什么。 例如，如果模型的主键字段叫做name，下面的两条语句是等同的：\n    >>> some_obj == other_obj\n    >>> some_obj.name == other_obj.name\n\n    ```\n\n\n\n- 删除对象\n    + 删除方法，为了方便，就取名为delete()。 该方法立即删除对象，并返回一个字典，该字典包含着删除的对象数量和每个对象类型的删除次数。 例如：\n    ```\n    >>> e.delete()\n    (1, {'weblog.Entry': 1})\n    ```\n\n\n    + 你还可以批量删除对象。 每个QuerySet 都有一个delete() 方法，它将删除该QuerySet中的所有成员。\n    ```\n    例如，下面的语句删除pub_date 为2005 的所有Entry 对象：\n    >>> Entry.objects.filter(pub_date__year=2005).delete()\n    (5, {'webapp.Entry': 5})\n\n    ```\n\n    + 当Django 删除一个对象时，它默认使用SQL ON DELETE CASCADE 约束 —— 换句话讲，任何有外键指向要删除对象的对象将一起删除。 像这样：\n    ```\n    b = Blog.objects.get(pk=1)\n    # This will delete the Blog and all of its Entry objects.\n    b.delete()\n    ```\n    +  注意，delete()是唯一没有在Manager上暴露出来的QuerySet方法。 这是一个安全机制来防止你意外地请求Entry.objects.delete()，而删除所有 的条目。 <font color=\"red\">如果你确实想删除所有的对象，你必须明确地请求一个完全的查询集：</font>\n    ```\n      Entry.objects.all().delete()\n    ```\n\n- 一次更新多个对象  \n    + 有时你想为一个QuerySet中所有对象的某个字段都设置一个特定的值。 这时你可以使用update() 方法。 像这样：\n    ```\n    # Update all the headlines with pub_date in 2007\n    Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')\n    ```\n    + 你只可以对非关联字段和ForeignKey 字段使用这个方法。 若要更新一个非关联字段，只需提供一个新的常数值。 <font color=\"red\">若要更新ForeignKey 字段，需设置新的值为你想指向的新的模型实例</font>。 像这样：\n\n    ```\n    >>> b = Blog.objects.get(pk=1)\n    # Change every Entry so that it belongs to this Blog.\n    >>> Entry.objects.all().update(blog=b)\n    ```\n\n    + update() 方法会立即执行并返回查询匹配的行数（如果有些行已经具有新的值，返回的行数可能和被更新的行数不相等）。 正在更新的QuerySet的唯一限制是它只能访问一个数据库表：模型的主表。 <font color=\"red\">你可以根据关联的字段过滤，但是你只能更新模型主表中的列。</font> 例如：\n    ```\n    >>> b = Blog.objects.get(pk=1)\n    # Update all the headlines belonging to this Blog.\n    >>> Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')\n    ```\n    + 要注意update() 方法会直接转换成一个SQL 语句。 它是一个批量的直接更新操作。 它不会运行模型的save() 方法，或者发出pre_save 或 post_save信号（调用save()方法产生）或者查看auto_now 字段选项。 如果你想保存QuerySet中的每个条目并确保每个实例的save() 方法都被调用，你不需要使用任何特殊的函数来处理。 只需要迭代它们并调用save()：\n    ```\n    for item in my_queryset:\n        item.save()\n    ```\n\n    + 对update 的调用也可以使用F expressions 来根据模型中的一个字段更新另外一个字段。 这对于在当前值的基础上加上一个值特别有用。 例如，增加Blog 中每个Entry 的pingback 个数：\n    ```\n    >>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)\n    ```\n\n    + 然而，与filter 和exclude 子句中的F() 对象不同，<font color=\"red\">在update 中你不可以使用F() 对象引入join —— 你只可以引用正在更新的模型的字段</font>。 如果你尝试使用F()对象引入一个join，将引发一个FieldError：\n    ```\n    # This will raise a FieldError\n    >>> Entry.objects.update(headline=F('blog__name'))\n    ```\n\n\n- <font color=\"red\">一对多关系</font>  \n\n    + <font color=\"red\">正向查询：</font>\n    + 如果一个模型具有ForeignKey，那么该模型的实例将可以通过属性访问关联的（外部）对象。 例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> e.blog # Returns the related Blog object.\n    ```\n\n    + 你可以通过外键属性获取和设置。 和你预期的一样，对外键的修改不会保存到数据库中直至你调用save()。 例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> e.blog = some_blog\n    >>> e.save()\n    ```\n    + 如果ForeignKey 字段有NULL 设置（即它允许null=True 值），你可以分配None 来删除对应的关联性。  例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> e.blog = None\n    >>> e.save() # \"UPDATE blog_entry SET blog_id = NULL ...;\"\n    ```\n    + 一对多关联关系的前向访问在第一次访问关联的对象时被缓存。 以后对同一个对象的外键的访问都使用缓存。  例如：\n    ```\n    >>> e = Entry.objects.get(id=2)\n    >>> print(e.blog)  # Hits the database to retrieve the associated Blog.\n    >>> print(e.blog)  # Doesn't hit the database; uses cached version.\n    ```\n\n    + 注意select_related() QuerySet方法递归地预填充所有的一对多关系到缓存中。 例如：\n    ```\n    ```\n\n\n    + <font color=\"red\">反向查询</font>\n    + 如果模型有一个ForeignKey，那么该ForeignKey所指的模型实例可以通过一个Manager返回第一个模型的所有实例。 默认情况下，这个Manager的名字为FOO_set，其中FOO是源模型的小写名称。 该Manager返回QuerySets，可以用上一节提到的方式进行过滤和操作。例如：\n    ```\n    >>> b = Blog.objects.get(id=1)\n    >>> b.entry_set.all() # Returns all Entry objects related to Blog.\n\n    # b.entry_set is a Manager that returns QuerySets.\n    >>> b.entry_set.filter(headline__contains='Lennon')\n    >>> b.entry_set.count()\n    \n    ```\n\n    + 你可以在ForeignKey 定义时设置related_name 参数来覆盖FOO_set 的名称。 例如，如果Entry模型更改为blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name='entries')，上述示例代码如下所示：\n    ```\n    >>> b = Blog.objects.get(id=1)\n    >>> b.entries.all() # Returns all Entry objects related to Blog.\n\n    # b.entries is a Manager that returns QuerySets.\n    >>> b.entries.filter(headline__contains='Lennon')\n    >>> b.entries.count()\n    ```\n\n    + 处理关联对象其他方法\n        * https://yiyibooks.cn/xx/Django_1.11.6/ref/models/relations.html\n        * add（），create（），remove（），set（）\n\n    + <font color=\"red\">这一节中提到的每个”反向“操作都会立即对数据库产生作用。 每个添加、创建和删除操作都会立即并自动保存到数据库中。</font>\n\n\n- 多对多关系\n    + 多对多关系的两端都会自动获得访问另一端的API。 这些API 的工作方式与上面提到的“方向”一对多关系一样。\n    + 唯一的区别在于属性的命名：定义 ManyToManyField 的模型使用该字段的属性名称，而“反向”模型使用源模型的小写名称加上'_set' （和一对多关系一样）。\n    + 例如：\n    ```\n    e = Entry.objects.get(id=3)\n    e.authors.all() # Returns all Author objects for this Entry.\n    e.authors.count()\n    e.authors.filter(name__contains='John')\n\n    a = Author.objects.get(id=5)\n    a.entry_set.all() # Returns all Entry objects for this Author.\n\n    ```\n\n    + 类似ForeignKey，ManyToManyField 可以指定related_name。 在上面的例子中，如果entry_set 中的ManyToManyField 指定entries，那么Entry 实例将使用 related_name='entries' 属性而不是Author。\n\n\n- 一对一关系\n    + 一对一关系与多对一关系非常相似。 如果你在模型中定义一个OneToOneField，该模型的实例将可以通过该模型的一个简单属性访问关联的模型。\n    + 例如：\n    ```\n    class EntryDetail(models.Model):\n    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)\n    details = models.TextField()\n\n    ed = EntryDetail.objects.get(id=2)\n    ed.entry # Returns the related Entry object.\n    ```\n\n\n    + 在“反向”查询中有所不同。 一对一关系中的关联模型同样具有一个Manager对象，但是该Manager表示一个单一的对象而不是对象的集合：\n    ```\n    e = Entry.objects.get(id=2)\n    e.entrydetail # returns the related EntryDetail object\n\n    ```\n\n\n\n\n\n\n\n### url\n\n\n\n### 视图（View）\n\n\n\n\n\n\n### 模板（templates）\n\n\n\n\n\n\n### setting文件","slug":"Django-基础篇2","published":1,"updated":"2018-08-29T16:01:26.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlnxkczw000fpstfpy24rgao","content":"<h3 id=\"常用命令：\"><a href=\"#常用命令：\" class=\"headerlink\" title=\"常用命令：\"></a>常用命令：</h3><ul>\n<li><p>创建项目：</p>\n<ul>\n<li>django-admin startproject 项目名称</li>\n</ul>\n</li>\n<li><p>创建应用：</p>\n<ul>\n<li>python manage.py startapp test  </li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>生成迁移文件：</p>\n<ul>\n<li>python manage.py makemigrations</li>\n</ul>\n</li>\n<li><p>执行迁移：</p>\n<ul>\n<li>python manage.py migrate （app名）  </li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>创建管理员:</p>\n<ul>\n<li>python manage.py createsuperuser</li>\n</ul>\n</li>\n<li><p>启动服务器:</p>\n<ul>\n<li>python manage.py runserver</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>查看虚拟环境中安装了哪些包 </p>\n<ul>\n<li>pip list</li>\n</ul>\n</li>\n<li><p>虚拟环境中的包收集到requirements.txt中</p>\n<ul>\n<li>pip freeze &gt;requirement.txt </li>\n</ul>\n</li>\n<li><p>安装requirements.txt中的包</p>\n<ul>\n<li>pip install -r requirements.txt</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模型（Model）\"><a href=\"#模型（Model）\" class=\"headerlink\" title=\"模型（Model）\"></a>模型（Model）</h3><h4 id=\"字段类型和字段操作\"><a href=\"#字段类型和字段操作\" class=\"headerlink\" title=\"字段类型和字段操作\"></a>字段类型和字段操作</h4><ul>\n<li>可通过右侧目录查看具体字段类型和字段操作用法</li>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html</a> </li>\n</ul>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/field_types.png\">  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/field_options.png\">  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/other_fields.png\">\n<ul>\n<li><p>模型的 Meta 选项  </p>\n<ul>\n<li><p>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html</a>  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/meta.png\">  \n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"model的使用\"><a href=\"#model的使用\" class=\"headerlink\" title=\"model的使用\"></a>model的使用</h4><ul>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/topics/db/queries.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/topics/db/queries.html</a></li>\n<li><p>后面栗子中用到的模型：</p>\n  <figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from django.db import models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blog</span>(<span class=\"title\">models</span>.<span class=\"title\">Model</span>):</span></span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">100</span>)</span><br><span class=\"line\">    tagline = models.TextField()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span>:              <span class=\"comment\"># __unicode__ on Python 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Author</span>(<span class=\"title\">models</span>.<span class=\"title\">Model</span>):</span></span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">200</span>)</span><br><span class=\"line\">    email = models.EmailField()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span>:              <span class=\"comment\"># __unicode__ on Python 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>(<span class=\"title\">models</span>.<span class=\"title\">Model</span>):</span></span><br><span class=\"line\">    blog = models.ForeignKey(Blog)<span class=\"comment\">#Blog 和 Entry 是一对多的关系</span></span><br><span class=\"line\">    headline = models.CharField(max_length=<span class=\"number\">255</span>)</span><br><span class=\"line\">    body_text = models.TextField()</span><br><span class=\"line\">    pub_date = models.DateField()</span><br><span class=\"line\">    mod_date = models.DateField()</span><br><span class=\"line\">    authors = models.ManyToManyField(Author)<span class=\"comment\">#Author 和 Entry 是多对多的关系</span></span><br><span class=\"line\">    n_comments = models.IntegerField()</span><br><span class=\"line\">    n_pingbacks = models.IntegerField()</span><br><span class=\"line\">    rating = models.IntegerField()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span>:              <span class=\"comment\"># __unicode__ on Python 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.headline</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建对象</p>\n<ul>\n<li>一个模型类代表数据库中的一个表，一个模型类的实例代表这个数据库表中的一条特定的记录。</li>\n<li>使用关键字参数实例化模型实例来创建一个对象，然后调用save() 把它保存到数据库中。</li>\n<li><p>例子：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; from blog.models import Blog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog(name=<span class=\"string\">'Beatles Blog'</span>, tagline=<span class=\"string\">'All the latest Beatles news.'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上面的代码在背后执行了SQL 的INSERT 语句。 <font color=\"red\">在你显式调用save()之前，Django 不会访问数据库。</font></p>\n</li>\n</ul>\n</li>\n<li><p>保存ForeignKey和ManyToManyField字段</p>\n<ul>\n<li><p>更新ForeignKey 字段的方式和保存普通字段相同 — 只要把一个正确类型的对象赋值给该字段。 下面的例子更新一个Entry实例entry的blog属性，假设Entry和Blog已经有正确的实例保存在数据库中（所以我们可以像下面这样获取它们）：  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from blog<span class=\"selector-class\">.models</span> import Blog, Entry   </span><br><span class=\"line\"></span><br><span class=\"line\">entry = Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.get</span>(pk=<span class=\"number\">1</span>)    </span><br><span class=\"line\">cheese_blog = Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.get</span>(name=<span class=\"string\">\"Cheddar Talk\"</span>)    </span><br><span class=\"line\">entry<span class=\"selector-class\">.blog</span> = cheese_blog    </span><br><span class=\"line\">entry.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新ManyToManyField 的方式有一些不同 — <font color=\"red\">需要使用字段的add()方法来增加关联关系的一条记录。 </font>&gt;下面这个例子向entry对象添加Author类的实例joe：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from blog<span class=\"selector-class\">.models</span> import Author</span><br><span class=\"line\">&gt;&gt;&gt; joe = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"Joe\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; entry<span class=\"selector-class\">.authors</span><span class=\"selector-class\">.add</span>(joe)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了在一条语句中，向ManyToManyField添加多条记录，可以在调用add()方法时传入多个参数，像这样：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; john = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"John\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; paul = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"Paul\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; george = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"George\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; ringo = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"Ringo\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; entry<span class=\"selector-class\">.authors</span><span class=\"selector-class\">.add</span>(john, paul, george, ringo)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>检索对象</p>\n<ul>\n<li>通过模型中的Manager构造一个QuerySet，来从你的数据库中获取对象。</li>\n<li><font color=\"red\">  QuerySet表示从数据库中取出来的对象的集合。 </font>它可以含有零个、一个或者多个过滤器。 过滤器基于所给的参数限制查询的结果。 从SQL 的角度来看，QuerySet和SELECT 语句等价，过滤器是像WHERE 和LIMIT 一样的限制子句。</li>\n<li>你可以从模型的Manager那里取得QuerySet。 每个模型都至少有一个Manager，<font color=\"red\">它默认命名为objects。  </font></li>\n<li>对于一个模型来说，Manager是QuerySets的主要来源。 例如， Blog.objects.all() 返回一个QuerySet，<font color=\"red\">这个QuerySet包含数据库中所有Blog对象，即Blog表中所有的记录.</font></li>\n</ul>\n</li>\n<li><p>关于QuerySet及其他QuerySet方法</p>\n<ul>\n<li><p>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.query.QuerySet\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.query.QuerySet</a>  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet1.png\">  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet2.png\"> <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet3.png\"> <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet4.png\"> \n</li>\n</ul>\n</li>\n<li><p>检索所有对象</p>\n<ul>\n<li><p>获取一个表中所有对象的最简单的方式是全部获取。 可以使用Manager的all() 方法：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; all_entries = Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>all()方法返回包含数据库中所有对象的一个QuerySet。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>使用过滤器检索特定对象</p>\n<ul>\n<li><p>all() 方法返回了一个包含数据库表中所有记录QuerySet。 但在通常情况下，你往往想要获取的是完整数据集的一个子集。</p>\n</li>\n<li><p>要创建这样一个子集，你需要在原始的的QuerySet上增加一些过滤条件。 QuerySet两个最普遍的途径是：</p>\n<ul>\n<li>filter(**kwargs)<ul>\n<li>返回一个新的QuerySet，它包含满足查询参数的对象。</li>\n</ul>\n</li>\n<li><p>exclude(**kwargs)</p>\n<ul>\n<li>返回一个新的QuerySet，它包含不满足查询参数的对象。</li>\n</ul>\n</li>\n<li><p>举个例子，要获取年份为2006的所有文章的QuerySet，可以使用filter()方法：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(pub_date__year=<span class=\"number\">2006</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用默认的管理器，它相当于：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>().<span class=\"attribute\">filter</span>(pub_date__year=<span class=\"number\">2006</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>链式过滤器</p>\n<ul>\n<li>QuerySet的筛选结果本身还是QuerySet，所以可以将筛选语句链接在一起。 像这样：<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry.objects.filter(</span><br><span class=\"line\"><span class=\"built_in\">..</span>.     <span class=\"attribute\">headline__startswith</span>=<span class=\"string\">'What'</span></span><br><span class=\"line\"><span class=\"built_in\">..</span>. ).exclude(</span><br><span class=\"line\"><span class=\"built_in\">..</span>.     <span class=\"attribute\">pub_date__gte</span>=datetime.date.today()</span><br><span class=\"line\"><span class=\"built_in\">..</span>. ).filter(</span><br><span class=\"line\"><span class=\"built_in\">..</span>.     <span class=\"attribute\">pub_date__gte</span>=datetime(2005, 1, 30)</span><br><span class=\"line\"><span class=\"built_in\">..</span>. )</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>QuerySet是惰性的</p>\n<ul>\n<li>QuerySets 是惰性执行的,创建QuerySet不会带来任何数据库的访问。一般来说，只有在“请求”QuerySet 的结果时才会到数据库中去获取它们。 当你确实需要结果时，QuerySet 通过访问数据库来求值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>使用get()检索单个对象</p>\n<ul>\n<li><font color=\"red\">filter() 始终给你一个QuerySet，</font>即使只有一个对象满足查询条件 —— 这种情况下，QuerySet将只包含一个元素。</li>\n<li><p>如果你知道只有一个对象满足你的查询，你可以使用Manager的get() 方法，<font color=\"red\">它直接返回该对象：</font></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; one_entry = Entry.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，使用get() 和使用filter() 的切片[0] 有一点区别。 如果没有结果满足查询，get() 将引发一个DoesNotExist 异常。 这个异常是正在查询的模型类的一个属性 —— 所以在上面的代码中，如果没有主键(pk) 为1 的Entry对象，Django 将引发一个Entry.DoesNotExist 。</p>\n</li>\n<li><p>类似地，如果有多条记录满足get() 的查询条件，Django 也将报错。 这种情况将引发MultipleObjectsReturned，它同样是模型类自身的一个属性。</p>\n</li>\n</ul>\n</li>\n<li><p>限制QuerySet</p>\n<ul>\n<li>可以使用Python 的切片语法来限制QuerySet记录的数目 。 它等同于SQL 的OFFSET 和LIMIT 子句。</li>\n<li>例如:<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()[:<span class=\"number\">5</span>]</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()[<span class=\"number\">5</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.order_by</span>(<span class=\"string\">'headline'</span>)[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>字段查找</p>\n<ul>\n<li>字段查询是指如何指定SQL WHERE 子句的内容。 它们通过QuerySet方法filter()、exclude() 和 get() 的关键字参数指定。</li>\n<li><p><font color=\"red\">查询的关键字参数的基本形式是field__lookuptype=value。 （中间是两个下划线）。</font>  像这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(pub_date__lte=<span class=\"string\">'2006-01-01'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; 翻译成SQL（大体）是：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; SELECT * FROM blog_entry WHERE pub_date &lt;= <span class=\"string\">'2006-01-01'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询条件中指定的字段必须是模型字段的名称。 但有一个例外，<font color=\"red\">对于ForeignKey你可以使用字段名加上_id 后缀。 在这种情况下，该参数的值应该是外键的原始值</font> 。 像这样：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(blog_id=<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你传递的是一个不合法的参数，查询函数将引发 TypeError。</p>\n</li>\n<li><p>数据库API支持大约二十种查找类型；参考文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#field-lookups\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#field-lookups</a> ；<font color=\"red\">搜索定位：Field查找。</font></p>\n</li>\n</ul>\n</li>\n<li><p><font color=\"red\">跨关联关系的查询</font></p>\n<ul>\n<li>Django 提供一种强大而又直观的方式来“处理”查询中的关联关系，它在后台自动帮你处理JOIN。 <font color=\"red\">若要跨越关联关系，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段</font>：</li>\n<li><p>下面这个例子获取所有Blog 的name 为’Beatles Blog’ 的Entry 对象：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(blog__name=<span class=\"string\">'Beatles Blog'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>它还可以反向工作。 若要引用一个“反向”的关系，只需要使用该模型的小写的名称。<br>下面的示例获取所有的Blog 对象，它们至少有一个Entry 的headline包含’Lennon’：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(entry__headline__contains=<span class=\"string\">'Lennon'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你在多个关联关系过滤而且其中某个中介模型没有满足过滤条件的值，Django 将把它当做一个空的（所有的值都为NULL）但是合法的对象。 这意味着不会有错误引发。 例如，在下面的过滤器中：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(entry__authors__name=<span class=\"string\">'Lennon'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（如果有一个相关联的Author 模型），如果没有author与entry关联，那么它将当作其没有name，而不会因为没有author 引发一个错误。 通常，这就是你想要的。 唯一可能让你困惑的是当你使用isnull 的时候。 因此：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.filter(<span class=\"attribute\">entry__authors__name__isnull</span>=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回的Blog对象包括author的name为空的对象，以及entry上的author为空的对象。 如果你不需要后者，你可以这样写：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.filter(<span class=\"attribute\">entry__authors__isnull</span>=<span class=\"literal\">False</span>, <span class=\"attribute\">entry__authors__name__isnull</span>=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>跨越多值的关联关系</p>\n<ul>\n<li><p>选择所有包含 <font color=\"red\">同时满足两个条件的entry的blog</font> ，这两个条件是headline 包含Lennon 和发表时间是2008 <font color=\"red\">（同一个entry 满足两个条件）</font> ，我们的代码是：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.filter(<span class=\"attribute\">entry__headline__contains</span>=<span class=\"string\">'Lennon'</span>, <span class=\"attribute\">entry__pub_date__year</span>=2008)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要选择所有这样的blog，有一个entry的headline包含“Lennon”和有一个entry发表时间是2008，我们将这样编写：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(entry__headline__contains=<span class=\"string\">'Lennon'</span>).<span class=\"attribute\">filter</span>(entry__pub_date__year=<span class=\"number\">2008</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假设这里有一个blog拥有一条包含’Lennon’的entries条目和一条来自2008的entries条目,但是没有一条来自2008并且包含”Lennon”的entries条目。 第一个查询不会返回任何blog，第二个查询将会返回一个blog。</p>\n</li>\n<li><p>在第二个例子中， 第一个filter限定查询集为所有与headline包含“Lennon”的entry关联的blog。 第二个filter进一步限定查询集中的blog，这些blog关联的entry 的发表时间是2008。 第二个filter 过滤出来的entry 与第一个filter 过滤出来的entry 可能相同也可能不同。 <font color=\"red\">我们用每个filter语句过滤的是Blog，而不是Entry。</font></p>\n</li>\n<li><p>跨越多值关系的filter() 查询的行为，与exclude() 实现的不同。 单个exclude() 调用中的条件不必引用同一个记录。</p>\n</li>\n<li><p>例如，下面的查询将<font color=\"red\">排除两种 </font>entry的blog，headline中包含“Lennon”的entry和在2008年发布的entry：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.exclude(</span><br><span class=\"line\">    <span class=\"attribute\">entry__headline__contains</span>=<span class=\"string\">'Lennon'</span>,</span><br><span class=\"line\">    <span class=\"attribute\">entry__pub_date__year</span>=2008,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而，这与使用filter() 的行为不同，它不是排除<font color=\"red\">同时满足</font>两个条件的Entry。 为了实现这点，即选择的Blog中不包含在2008年发布且healine 中带有“Lennon” 的Entry，你需要编写两个查询：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.exclude(</span><br><span class=\"line\">    <span class=\"attribute\">entry__in</span>=Entry.objects.filter(</span><br><span class=\"line\">        <span class=\"attribute\">headline__contains</span>=<span class=\"string\">'Lennon'</span>,</span><br><span class=\"line\">        <span class=\"attribute\">pub_date__year</span>=2008,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>过滤器可以引用模型的字段</p>\n<ul>\n<li><p>查询表达式</p>\n<ul>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/expressions.html#django.db.models.F\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/expressions.html#django.db.models.F</a>  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/F.png\">\n</li>\n</ul>\n</li>\n<li><p>将模型的一个字段与同一个模型的另外一个字段进行比较</p>\n</li>\n<li><p>Django 提供F表达式 来允许这样的比较。 <font color=\"red\">F() 返回的实例用作查询内部对模型字段的引用。</font> 这些引用可以用于查询的filter 中来<font color=\"red\">比较相同模型实例上</font>不同字段之间值的比较。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，为了查找comments 数目多于pingbacks 的Entry，我们将构造一个F() 对象来引用pingback 数目，并在查询中使用该F() 对象：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; from django<span class=\"selector-class\">.db</span><span class=\"selector-class\">.models</span> import F</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(n_comments__gt=F(<span class=\"string\">'n_pingbacks'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Django 支持对F() 对象使用加法、减法、乘法、除法、取模以及幂计算等算术操作，两个操作数可以都是常数和其它F() 对象。</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了查找comments 数目比pingbacks 两倍还要多的<span class=\"keyword\">Entry</span>，我们将查询修改为：</span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">Entry</span>.objects.filter(n_comments__gt=F(<span class=\"symbol\">'n_pingbacks</span>') * <span class=\"number\">2</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">为了查询rating 比pingback 和comment 数目总和要小的<span class=\"keyword\">Entry</span>，我们将这样查询：</span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">Entry</span>.objects.filter(rating__lt=F(<span class=\"symbol\">'n_comments</span>') + F(<span class=\"symbol\">'n_pingbacks</span>'))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你还可以在F() 对象中使用双下划线标记来跨越关联关系。 带有双下划线的F() 对象将引入任何需要的join 操作以访问关联的对象。 </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，如要获取author 的名字与blog 名字相同的Entry，我们可以这样查询：</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(authors__name=F(<span class=\"string\">'blog__name'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于date 和date/time 字段，你可以给它们加上或减去一个timedelta 对象。 </p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面的例子将返回发布超过<span class=\"number\">3</span>天后被修改的所有Entry：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; from datetime import timedelta</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(mod_date__gt=F(<span class=\"string\">'pub_date'</span>) + timedelta(days=<span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>pk查找快捷方式</p>\n<ul>\n<li><p>为了方便，Django 提供一个查询快捷方式pk ，它表示“primary key” 的意思</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在示例Blog模型中，主键pk是id字段，所以这三个语句是等价的：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id__exact</span>=14) # Explicit form</span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id</span>=14) # __exact is implied</span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=14) # pk implies id__exact</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pk的使用并不限于__ exact查询 - 任何查询词都可以与pk组合来执行查询一个模型的primary key：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Get blogs entries with id <span class=\"number\">1</span>, <span class=\"number\">4</span> and <span class=\"number\">7</span></span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.filter(pk__in=[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"># Get all blog entries with id &gt; <span class=\"number\">14</span></span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.filter(pk__gt=<span class=\"number\">14</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pk查询在join 中也可以工作。 例如，下面三个语句是等同的：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(blog__id__exact=<span class=\"number\">3</span>) <span class=\"comment\"># Explicit form</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(blog__id=<span class=\"number\">3</span>)        <span class=\"comment\"># __exact is implied</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(blog__pk=<span class=\"number\">3</span>)        <span class=\"comment\"># __pk implies __id__exact</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>在LIKE语句中转义百分号和下划线</p>\n<ul>\n<li><p>与endswith SQL 语句等同的字段查询（LIKE、 istartswith、isendswith、isexact、 LIKE、startswith 和contains）将自动转义在contains 语句中使用的两个特殊的字符 —— 百分号和下划线。 （在LIKE 语句中，百分号通配符表示多个字符，下划线通配符表示单个字符）。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，要获取包含一个百分号的所有的Entry，只需要像其它任何字符一样使用百分号：</span><br><span class=\"line\">&gt;&gt;&gt; Entry.objects.filter(headline__contains=<span class=\"string\">'%'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">Django照顾你的引用；生成的SQL将如下所示：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"params\">...</span> <span class=\"keyword\">WHERE</span> headline LIKE <span class=\"string\">'%\\%%'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>缓存和QuerySet</p>\n<ul>\n<li>每个QuerySet都包含一个缓存来最小化对数据库的访问。 理解它是如何工作的将让你编写最高效的代码。</li>\n<li><p>在一个新创建的QuerySet中，缓存为空。 首次对QuerySet进行求值 —— 同时发生数据库查询 ——Django <font color=\"red\">将保存查询的结果到QuerySet的缓存中并返回明确请求的结果</font>（例如，如果正在迭代QuerySet，则返回下一个结果）。 接下来对该QuerySet 的求值将重用缓存的结果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请牢记这个缓存行为，因为对QuerySet使用不当的话，它会坑你的。 例如，下面的语句创建两个QuerySet，对它们求值，然后扔掉它们：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([e.headline <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> Entry.objects.all()])</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([e.pub_date <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> Entry.objects.all()])</span></span><br><span class=\"line\">这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。 同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Entry被添加进来或删除掉。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">为了避免这个问题，只需保存QuerySet并重新使用它：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; queryset = Entry.objects.all()</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([p.headline <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> queryset]) <span class=\"comment\"># Evaluate the query set.</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([p.pub_date <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> queryset]) <span class=\"comment\"># Re-use the cache from the evaluation.</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>当QuerySet不缓存</p>\n<ul>\n<li><p>查询集不会永远缓存它们的结果。 当只对查询集的部分进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。 特别地，这意味着使用切片或索引来limiting the queryset将不会填充缓存。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，重复获取查询集对象中一个特定的索引将每次都查询数据库：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; queryset = Entry.objects.all()</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Queries the database</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Queries the database again</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">然而，如果已经对全部查询集求值过，则将检查缓存：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; queryset = Entry.objects.all()</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; [entry <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> queryset] <span class=\"comment\"># Queries the database</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Uses cache</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Uses cache</span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">下面是一些其它例子，它们会使得全部的查询集被求值并填充到缓存中：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; [entry <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> queryset]</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; bool(queryset)</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; entry <span class=\"keyword\">in</span> queryset</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; list(queryset)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>使用Q对象进行复杂查找</p>\n<ul>\n<li>在filter()中的关键字参数查询 — — 是“AND”的关系。 如果你需要执行更复杂的查询（例如OR 语句），你可以使用Q对象。</li>\n<li>Q object (django.db.models.Q) 对象用于封装一组关键字参数。 这些关键字参数就是上文“字段查询” 中所提及的那些。<ul>\n<li>文档： <a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.Q\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.Q</a>  搜索：Q()对象</li>\n</ul>\n</li>\n<li><p>Q对象可以使用&amp;和|操作符组合起来。 当一个操作符在两个Q 对象上使用时，它产生一个新的Q 对象。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，下面的语句产生一个<span class=\"string\">\"question__startswith\"</span> 对象，表示两个Q 查询的“<span class=\"literal\">OR</span>” ：</span><br><span class=\"line\">Q(question__startswith=<span class=\"string\">'Who'</span>) | Q(question__startswith=<span class=\"string\">'What'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">它等同于下面的SQL <span class=\"keyword\">WHERE</span> 子句：</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> question LIKE <span class=\"string\">'Who%'</span> <span class=\"literal\">OR</span> question LIKE <span class=\"string\">'What%'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你可以组合&amp; 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。 同时，~ 对象可以使用NOT 操作符取反，</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这允许组合正常的查询和取反(Q) 查询：</span><br><span class=\"line\">Q(<span class=\"attribute\">question__startswith</span>=<span class=\"string\">'Who'</span>) | ~Q(<span class=\"attribute\">pub_date__year</span>=2005)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>每个接受关键字参数的查询函数（例如filter()、exclude()、get()）都可以传递一个或多个Q 对象作为位置（不带名的）参数。 如果一个查询函数有多个Q 对象参数，这些参数的逻辑关系为“AND”。 像这样：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Poll.objects.get(</span><br><span class=\"line\">    Q(question__startswith='Who'),</span><br><span class=\"line\">    Q(pub_date=date(<span class=\"number\">2005</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>)) | Q(pub_date=date(<span class=\"number\">2005</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">...大致翻译成SQL：</span><br><span class=\"line\">SELECT * from polls WHERE question LIKE 'Who%'</span><br><span class=\"line\">    AND (pub_date = '<span class=\"number\">2005</span><span class=\"number\">-05</span><span class=\"number\">-02</span>' OR pub_date = '<span class=\"number\">2005</span><span class=\"number\">-05</span><span class=\"number\">-06</span>')</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询函数可以混合使用Q和关键字参数。 所有提供给查询函数的参数（关键字参数或Q 对象）都将”AND”在一起。<font color=\"red\"> 但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 </font></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">像这样：</span><br><span class=\"line\">Poll.objects.<span class=\"builtin-name\">get</span>(</span><br><span class=\"line\">    Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 2)) | Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 6)),</span><br><span class=\"line\">    <span class=\"attribute\">question__startswith</span>=<span class=\"string\">'Who'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">..</span>.将是一个有效的查询，相当于前面的例子；但：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># INVALID QUERY</span></span><br><span class=\"line\">Poll.objects.<span class=\"builtin-name\">get</span>(</span><br><span class=\"line\">    <span class=\"attribute\">question__startswith</span>=<span class=\"string\">'Who'</span>,</span><br><span class=\"line\">    Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 2)) | Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 6))</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">..</span>.不会有效</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>比较对象</p>\n<ul>\n<li>为了比较两个模型实例，只需要使用标准的Python 比较操作符，即双等于符号：==。 在后台，它会比较两个模型主键的值。<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">利用上面的Entry 示例，下面两个语句是等同的：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_entry == other_entry</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_entry.id == other_entry.id</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">如果模型的主键不叫id，也没有问题。 比较将始终使用主键，无论它叫什么。 例如，如果模型的主键字段叫做name，下面的两条语句是等同的：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_obj == other_obj</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_obj.name == other_obj.name</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>删除对象</p>\n<ul>\n<li><p>删除方法，为了方便，就取名为delete()。 该方法立即删除对象，并返回一个字典，该字典包含着删除的对象数量和每个对象类型的删除次数。 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.delete()</span><br><span class=\"line\">(<span class=\"number\">1</span>, &#123;<span class=\"string\">'weblog.Entry'</span>: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你还可以批量删除对象。 每个QuerySet 都有一个delete() 方法，它将删除该QuerySet中的所有成员。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，下面的语句删除pub_date 为<span class=\"number\">2005</span> 的所有Entry 对象：</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(pub_date__year=<span class=\"number\">2005</span>).delete()</span><br><span class=\"line\">(<span class=\"number\">5</span>, &#123;<span class=\"string\">'webapp.Entry'</span>: <span class=\"number\">5</span>&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当Django 删除一个对象时，它默认使用SQL ON DELETE CASCADE 约束 —— 换句话讲，任何有外键指向要删除对象的对象将一起删除。 像这样：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=1)</span><br><span class=\"line\"><span class=\"comment\"># This will delete the Blog and all of its Entry objects.</span></span><br><span class=\"line\">b.delete()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，delete()是唯一没有在Manager上暴露出来的QuerySet方法。 这是一个安全机制来防止你意外地请求Entry.objects.delete()，而删除所有 的条目。 <font color=\"red\">如果你确实想删除所有的对象，你必须明确地请求一个完全的查询集：</font></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Entry</span><span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()<span class=\"selector-class\">.delete</span>()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>一次更新多个对象  </p>\n<ul>\n<li><p>有时你想为一个QuerySet中所有对象的某个字段都设置一个特定的值。 这时你可以使用update() 方法。 像这样：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Update <span class=\"keyword\">all</span> the headlines <span class=\"keyword\">with</span> pub_date <span class=\"keyword\">in</span> <span class=\"number\">2007</span></span><br><span class=\"line\"><span class=\"keyword\">Entry</span>.objects.filter(pub_date__year=<span class=\"number\">2007</span>).update(headline=<span class=\"symbol\">'Everything</span> <span class=\"keyword\">is</span> the same')</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你只可以对非关联字段和ForeignKey 字段使用这个方法。 若要更新一个非关联字段，只需提供一个新的常数值。 <font color=\"red\">若要更新ForeignKey 字段，需设置新的值为你想指向的新的模型实例</font>。 像这样：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; b = Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=1)</span><br><span class=\"line\"><span class=\"comment\"># Change every Entry so that it belongs to this Blog.</span></span><br><span class=\"line\">&gt;&gt;&gt; Entry.objects.all().update(<span class=\"attribute\">blog</span>=b)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>update() 方法会立即执行并返回查询匹配的行数（如果有些行已经具有新的值，返回的行数可能和被更新的行数不相等）。 正在更新的QuerySet的唯一限制是它只能访问一个数据库表：模型的主表。 <font color=\"red\">你可以根据关联的字段过滤，但是你只能更新模型主表中的列。</font> 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog.objects.get(pk=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># Update all the headlines belonging to this Blog.</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.select_related().filter(blog=b).update(headline=<span class=\"string\">'Everything is the same'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要注意update() 方法会直接转换成一个SQL 语句。 它是一个批量的直接更新操作。 它不会运行模型的save() 方法，或者发出pre_save 或 post_save信号（调用save()方法产生）或者查看auto_now 字段选项。 如果你想保存QuerySet中的每个条目并确保每个实例的save() 方法都被调用，你不需要使用任何特殊的函数来处理。 只需要迭代它们并调用save()：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">item</span> <span class=\"keyword\">in</span> my_queryset:</span><br><span class=\"line\">    <span class=\"built_in\">item</span>.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对update 的调用也可以使用F expressions 来根据模型中的一个字段更新另外一个字段。 这对于在当前值的基础上加上一个值特别有用。 例如，增加Blog 中每个Entry 的pingback 个数：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>().update(n_pingbacks=F(<span class=\"string\">'n_pingbacks'</span>) + <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而，与filter 和exclude 子句中的F() 对象不同，<font color=\"red\">在update 中你不可以使用F() 对象引入join —— 你只可以引用正在更新的模型的字段</font>。 如果你尝试使用F()对象引入一个join，将引发一个FieldError：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This will raise a FieldError</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.update(headline=F(<span class=\"string\">'blog__name'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><font color=\"red\">一对多关系</font>  \n\n<ul>\n<li><font color=\"red\">正向查询：</font></li>\n<li><p>如果一个模型具有ForeignKey，那么该模型的实例将可以通过属性访问关联的（外部）对象。 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e = Entry.objects.get(id=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.blog <span class=\"comment\"># Returns the related Blog object.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你可以通过外键属性获取和设置。 和你预期的一样，对外键的修改不会保存到数据库中直至你调用save()。 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e = Entry.objects.get(id=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.blog = some_blog</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果ForeignKey 字段有NULL 设置（即它允许null=True 值），你可以分配None 来删除对应的关联性。  例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e = Entry.objects.get(id=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.blog = None</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.save() <span class=\"comment\"># \"UPDATE blog_entry SET blog_id = NULL ...;\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一对多关联关系的前向访问在第一次访问关联的对象时被缓存。 以后对同一个对象的外键的访问都使用缓存。  例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; e = Entry.objects.get(id=2)</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(e.blog)  <span class=\"comment\"># Hits the database to retrieve the associated Blog.</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(e.blog)  <span class=\"comment\"># Doesn't hit the database; uses cached version.</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意select_related() QuerySet方法递归地预填充所有的一对多关系到缓存中。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n</li>\n<li><font color=\"red\">反向查询</font></li>\n<li><p>如果模型有一个ForeignKey，那么该ForeignKey所指的模型实例可以通过一个Manager返回第一个模型的所有实例。 默认情况下，这个Manager的名字为FOO_set，其中FOO是源模型的小写名称。 该Manager返回QuerySets，可以用上一节提到的方式进行过滤和操作。例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog.objects.get(id=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entry_set.all() <span class=\"comment\"># Returns all Entry objects related to Blog.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b.entry_set is a Manager that returns QuerySets.</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entry_set.filter(headline__contains=<span class=\"string\">'Lennon'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entry_set.count()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你可以在ForeignKey 定义时设置related_name 参数来覆盖FOO_set 的名称。 例如，如果Entry模型更改为blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)，上述示例代码如下所示：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog.objects.get(id=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entries.all() <span class=\"comment\"># Returns all Entry objects related to Blog.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b.entries is a Manager that returns QuerySets.</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entries.filter(headline__contains=<span class=\"string\">'Lennon'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entries.count()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理关联对象其他方法</p>\n<ul>\n<li><a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/relations.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/relations.html</a></li>\n<li>add（），create（），remove（），set（）</li>\n</ul>\n</li>\n<li><font color=\"red\">这一节中提到的每个”反向“操作都会立即对数据库产生作用。 每个添加、创建和删除操作都会立即并自动保存到数据库中。</font>\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>多对多关系</p>\n<ul>\n<li>多对多关系的两端都会自动获得访问另一端的API。 这些API 的工作方式与上面提到的“方向”一对多关系一样。</li>\n<li>唯一的区别在于属性的命名：定义 ManyToManyField 的模型使用该字段的属性名称，而“反向”模型使用源模型的小写名称加上’_set’ （和一对多关系一样）。</li>\n<li><p>例如：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e = Entry.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id</span>=3)</span><br><span class=\"line\">e.authors.all() # Returns all Author objects <span class=\"keyword\">for</span> this Entry.</span><br><span class=\"line\">e.authors.count()</span><br><span class=\"line\">e.authors.filter(<span class=\"attribute\">name__contains</span>=<span class=\"string\">'John'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">a = Author.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id</span>=5)</span><br><span class=\"line\">a.entry_set.all() # Returns all Entry objects <span class=\"keyword\">for</span> this Author.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类似ForeignKey，ManyToManyField 可以指定related_name。 在上面的例子中，如果entry_set 中的ManyToManyField 指定entries，那么Entry 实例将使用 related_name=’entries’ 属性而不是Author。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>一对一关系</p>\n<ul>\n<li>一对一关系与多对一关系非常相似。 如果你在模型中定义一个OneToOneField，该模型的实例将可以通过该模型的一个简单属性访问关联的模型。</li>\n<li><p>例如：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">EntryDetail</span>(<span class=\"title\">models</span>.<span class=\"type\">Model</span>):</span></span><br><span class=\"line\"><span class=\"class\">entry = models.<span class=\"type\">OneToOneField</span>(<span class=\"type\">Entry</span>, <span class=\"title\">on_delete</span>=<span class=\"title\">models</span>.<span class=\"type\">CASCADE</span>)</span></span><br><span class=\"line\"><span class=\"class\">details = models.<span class=\"type\">TextField</span>()</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">ed = <span class=\"type\">EntryDetail</span>.objects.get(<span class=\"title\">id</span>=2)</span></span><br><span class=\"line\"><span class=\"class\">ed.entry # <span class=\"type\">Returns</span> the related <span class=\"type\">Entry</span> object.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在“反向”查询中有所不同。 一对一关系中的关联模型同样具有一个Manager对象，但是该Manager表示一个单一的对象而不是对象的集合：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e = Entry.objects.<span class=\"keyword\">get</span>(<span class=\"built_in\">id</span>=<span class=\"number\">2</span>)</span><br><span class=\"line\">e.entrydetail <span class=\"comment\"># returns the related EntryDetail object</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h3><h3 id=\"视图（View）\"><a href=\"#视图（View）\" class=\"headerlink\" title=\"视图（View）\"></a>视图（View）</h3><h3 id=\"模板（templates）\"><a href=\"#模板（templates）\" class=\"headerlink\" title=\"模板（templates）\"></a>模板（templates）</h3><h3 id=\"setting文件\"><a href=\"#setting文件\" class=\"headerlink\" title=\"setting文件\"></a>setting文件</h3>","site":{"data":{}},"excerpt":"<h3 id=\"常用命令：\"><a href=\"#常用命令：\" class=\"headerlink\" title=\"常用命令：\"></a>常用命令：</h3><ul>\n<li><p>创建项目：</p>\n<ul>\n<li>django-admin startproject 项目名称</li>\n</ul>\n</li>\n<li><p>创建应用：</p>\n<ul>\n<li>python manage.py startapp test  </li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><p>生成迁移文件：</p>\n<ul>\n<li>python manage.py makemigrations</li>\n</ul>\n</li>\n<li><p>执行迁移：</p>\n<ul>\n<li>python manage.py migrate （app名）  </li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>创建管理员:</p>\n<ul>\n<li>python manage.py createsuperuser</li>\n</ul>\n</li>\n<li><p>启动服务器:</p>\n<ul>\n<li>python manage.py runserver</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>查看虚拟环境中安装了哪些包 </p>\n<ul>\n<li>pip list</li>\n</ul>\n</li>\n<li><p>虚拟环境中的包收集到requirements.txt中</p>\n<ul>\n<li>pip freeze &gt;requirement.txt </li>\n</ul>\n</li>\n<li><p>安装requirements.txt中的包</p>\n<ul>\n<li>pip install -r requirements.txt</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模型（Model）\"><a href=\"#模型（Model）\" class=\"headerlink\" title=\"模型（Model）\"></a>模型（Model）</h3><h4 id=\"字段类型和字段操作\"><a href=\"#字段类型和字段操作\" class=\"headerlink\" title=\"字段类型和字段操作\"></a>字段类型和字段操作</h4><ul>\n<li>可通过右侧目录查看具体字段类型和字段操作用法</li>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/fields.html</a> </li>\n</ul>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/field_types.png\">  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/field_options.png\">  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/other_fields.png\">\n<ul>\n<li><p>模型的 Meta 选项  </p>\n<ul>\n<li><p>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/options.html</a>  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/meta.png\">  \n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"model的使用\"><a href=\"#model的使用\" class=\"headerlink\" title=\"model的使用\"></a>model的使用</h4><ul>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/topics/db/queries.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/topics/db/queries.html</a></li>\n<li><p>后面栗子中用到的模型：</p>\n  <figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from django.db import models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blog</span>(<span class=\"title\">models</span>.<span class=\"title\">Model</span>):</span></span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">100</span>)</span><br><span class=\"line\">    tagline = models.TextField()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span>:              <span class=\"comment\"># __unicode__ on Python 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Author</span>(<span class=\"title\">models</span>.<span class=\"title\">Model</span>):</span></span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">200</span>)</span><br><span class=\"line\">    email = models.EmailField()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span>:              <span class=\"comment\"># __unicode__ on Python 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>(<span class=\"title\">models</span>.<span class=\"title\">Model</span>):</span></span><br><span class=\"line\">    blog = models.ForeignKey(Blog)<span class=\"comment\">#Blog 和 Entry 是一对多的关系</span></span><br><span class=\"line\">    headline = models.CharField(max_length=<span class=\"number\">255</span>)</span><br><span class=\"line\">    body_text = models.TextField()</span><br><span class=\"line\">    pub_date = models.DateField()</span><br><span class=\"line\">    mod_date = models.DateField()</span><br><span class=\"line\">    authors = models.ManyToManyField(Author)<span class=\"comment\">#Author 和 Entry 是多对多的关系</span></span><br><span class=\"line\">    n_comments = models.IntegerField()</span><br><span class=\"line\">    n_pingbacks = models.IntegerField()</span><br><span class=\"line\">    rating = models.IntegerField()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span>:              <span class=\"comment\"># __unicode__ on Python 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.headline</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建对象</p>\n<ul>\n<li>一个模型类代表数据库中的一个表，一个模型类的实例代表这个数据库表中的一条特定的记录。</li>\n<li>使用关键字参数实例化模型实例来创建一个对象，然后调用save() 把它保存到数据库中。</li>\n<li><p>例子：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; from blog.models import Blog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog(name=<span class=\"string\">'Beatles Blog'</span>, tagline=<span class=\"string\">'All the latest Beatles news.'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上面的代码在背后执行了SQL 的INSERT 语句。 <font color=\"red\">在你显式调用save()之前，Django 不会访问数据库。</font></p>\n</li>\n</ul>\n</li>\n<li><p>保存ForeignKey和ManyToManyField字段</p>\n<ul>\n<li><p>更新ForeignKey 字段的方式和保存普通字段相同 — 只要把一个正确类型的对象赋值给该字段。 下面的例子更新一个Entry实例entry的blog属性，假设Entry和Blog已经有正确的实例保存在数据库中（所以我们可以像下面这样获取它们）：  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from blog<span class=\"selector-class\">.models</span> import Blog, Entry   </span><br><span class=\"line\"></span><br><span class=\"line\">entry = Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.get</span>(pk=<span class=\"number\">1</span>)    </span><br><span class=\"line\">cheese_blog = Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.get</span>(name=<span class=\"string\">\"Cheddar Talk\"</span>)    </span><br><span class=\"line\">entry<span class=\"selector-class\">.blog</span> = cheese_blog    </span><br><span class=\"line\">entry.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新ManyToManyField 的方式有一些不同 — <font color=\"red\">需要使用字段的add()方法来增加关联关系的一条记录。 </font>&gt;下面这个例子向entry对象添加Author类的实例joe：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from blog<span class=\"selector-class\">.models</span> import Author</span><br><span class=\"line\">&gt;&gt;&gt; joe = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"Joe\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; entry<span class=\"selector-class\">.authors</span><span class=\"selector-class\">.add</span>(joe)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了在一条语句中，向ManyToManyField添加多条记录，可以在调用add()方法时传入多个参数，像这样：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; john = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"John\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; paul = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"Paul\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; george = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"George\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; ringo = Author<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.create</span>(name=<span class=\"string\">\"Ringo\"</span>)</span><br><span class=\"line\">&gt;&gt;&gt; entry<span class=\"selector-class\">.authors</span><span class=\"selector-class\">.add</span>(john, paul, george, ringo)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>检索对象</p>\n<ul>\n<li>通过模型中的Manager构造一个QuerySet，来从你的数据库中获取对象。</li>\n<li><font color=\"red\">  QuerySet表示从数据库中取出来的对象的集合。 </font>它可以含有零个、一个或者多个过滤器。 过滤器基于所给的参数限制查询的结果。 从SQL 的角度来看，QuerySet和SELECT 语句等价，过滤器是像WHERE 和LIMIT 一样的限制子句。</li>\n<li>你可以从模型的Manager那里取得QuerySet。 每个模型都至少有一个Manager，<font color=\"red\">它默认命名为objects。  </font></li>\n<li>对于一个模型来说，Manager是QuerySets的主要来源。 例如， Blog.objects.all() 返回一个QuerySet，<font color=\"red\">这个QuerySet包含数据库中所有Blog对象，即Blog表中所有的记录.</font></li>\n</ul>\n</li>\n<li><p>关于QuerySet及其他QuerySet方法</p>\n<ul>\n<li><p>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.query.QuerySet\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.query.QuerySet</a>  </p>\n<img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet1.png\">  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet2.png\"> <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet3.png\"> <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/QuerySet4.png\"> \n</li>\n</ul>\n</li>\n<li><p>检索所有对象</p>\n<ul>\n<li><p>获取一个表中所有对象的最简单的方式是全部获取。 可以使用Manager的all() 方法：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; all_entries = Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>all()方法返回包含数据库中所有对象的一个QuerySet。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>使用过滤器检索特定对象</p>\n<ul>\n<li><p>all() 方法返回了一个包含数据库表中所有记录QuerySet。 但在通常情况下，你往往想要获取的是完整数据集的一个子集。</p>\n</li>\n<li><p>要创建这样一个子集，你需要在原始的的QuerySet上增加一些过滤条件。 QuerySet两个最普遍的途径是：</p>\n<ul>\n<li>filter(**kwargs)<ul>\n<li>返回一个新的QuerySet，它包含满足查询参数的对象。</li>\n</ul>\n</li>\n<li><p>exclude(**kwargs)</p>\n<ul>\n<li>返回一个新的QuerySet，它包含不满足查询参数的对象。</li>\n</ul>\n</li>\n<li><p>举个例子，要获取年份为2006的所有文章的QuerySet，可以使用filter()方法：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(pub_date__year=<span class=\"number\">2006</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用默认的管理器，它相当于：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>().<span class=\"attribute\">filter</span>(pub_date__year=<span class=\"number\">2006</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>链式过滤器</p>\n<ul>\n<li>QuerySet的筛选结果本身还是QuerySet，所以可以将筛选语句链接在一起。 像这样：<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry.objects.filter(</span><br><span class=\"line\"><span class=\"built_in\">..</span>.     <span class=\"attribute\">headline__startswith</span>=<span class=\"string\">'What'</span></span><br><span class=\"line\"><span class=\"built_in\">..</span>. ).exclude(</span><br><span class=\"line\"><span class=\"built_in\">..</span>.     <span class=\"attribute\">pub_date__gte</span>=datetime.date.today()</span><br><span class=\"line\"><span class=\"built_in\">..</span>. ).filter(</span><br><span class=\"line\"><span class=\"built_in\">..</span>.     <span class=\"attribute\">pub_date__gte</span>=datetime(2005, 1, 30)</span><br><span class=\"line\"><span class=\"built_in\">..</span>. )</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>QuerySet是惰性的</p>\n<ul>\n<li>QuerySets 是惰性执行的,创建QuerySet不会带来任何数据库的访问。一般来说，只有在“请求”QuerySet 的结果时才会到数据库中去获取它们。 当你确实需要结果时，QuerySet 通过访问数据库来求值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>使用get()检索单个对象</p>\n<ul>\n<li><font color=\"red\">filter() 始终给你一个QuerySet，</font>即使只有一个对象满足查询条件 —— 这种情况下，QuerySet将只包含一个元素。</li>\n<li><p>如果你知道只有一个对象满足你的查询，你可以使用Manager的get() 方法，<font color=\"red\">它直接返回该对象：</font></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; one_entry = Entry.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，使用get() 和使用filter() 的切片[0] 有一点区别。 如果没有结果满足查询，get() 将引发一个DoesNotExist 异常。 这个异常是正在查询的模型类的一个属性 —— 所以在上面的代码中，如果没有主键(pk) 为1 的Entry对象，Django 将引发一个Entry.DoesNotExist 。</p>\n</li>\n<li><p>类似地，如果有多条记录满足get() 的查询条件，Django 也将报错。 这种情况将引发MultipleObjectsReturned，它同样是模型类自身的一个属性。</p>\n</li>\n</ul>\n</li>\n<li><p>限制QuerySet</p>\n<ul>\n<li>可以使用Python 的切片语法来限制QuerySet记录的数目 。 它等同于SQL 的OFFSET 和LIMIT 子句。</li>\n<li>例如:<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()[:<span class=\"number\">5</span>]</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()[<span class=\"number\">5</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.order_by</span>(<span class=\"string\">'headline'</span>)[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>字段查找</p>\n<ul>\n<li>字段查询是指如何指定SQL WHERE 子句的内容。 它们通过QuerySet方法filter()、exclude() 和 get() 的关键字参数指定。</li>\n<li><p><font color=\"red\">查询的关键字参数的基本形式是field__lookuptype=value。 （中间是两个下划线）。</font>  像这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(pub_date__lte=<span class=\"string\">'2006-01-01'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; 翻译成SQL（大体）是：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; SELECT * FROM blog_entry WHERE pub_date &lt;= <span class=\"string\">'2006-01-01'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询条件中指定的字段必须是模型字段的名称。 但有一个例外，<font color=\"red\">对于ForeignKey你可以使用字段名加上_id 后缀。 在这种情况下，该参数的值应该是外键的原始值</font> 。 像这样：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(blog_id=<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你传递的是一个不合法的参数，查询函数将引发 TypeError。</p>\n</li>\n<li><p>数据库API支持大约二十种查找类型；参考文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#field-lookups\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#field-lookups</a> ；<font color=\"red\">搜索定位：Field查找。</font></p>\n</li>\n</ul>\n</li>\n<li><p><font color=\"red\">跨关联关系的查询</font></p>\n<ul>\n<li>Django 提供一种强大而又直观的方式来“处理”查询中的关联关系，它在后台自动帮你处理JOIN。 <font color=\"red\">若要跨越关联关系，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段</font>：</li>\n<li><p>下面这个例子获取所有Blog 的name 为’Beatles Blog’ 的Entry 对象：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(blog__name=<span class=\"string\">'Beatles Blog'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>它还可以反向工作。 若要引用一个“反向”的关系，只需要使用该模型的小写的名称。<br>下面的示例获取所有的Blog 对象，它们至少有一个Entry 的headline包含’Lennon’：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(entry__headline__contains=<span class=\"string\">'Lennon'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你在多个关联关系过滤而且其中某个中介模型没有满足过滤条件的值，Django 将把它当做一个空的（所有的值都为NULL）但是合法的对象。 这意味着不会有错误引发。 例如，在下面的过滤器中：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(entry__authors__name=<span class=\"string\">'Lennon'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（如果有一个相关联的Author 模型），如果没有author与entry关联，那么它将当作其没有name，而不会因为没有author 引发一个错误。 通常，这就是你想要的。 唯一可能让你困惑的是当你使用isnull 的时候。 因此：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.filter(<span class=\"attribute\">entry__authors__name__isnull</span>=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回的Blog对象包括author的name为空的对象，以及entry上的author为空的对象。 如果你不需要后者，你可以这样写：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.filter(<span class=\"attribute\">entry__authors__isnull</span>=<span class=\"literal\">False</span>, <span class=\"attribute\">entry__authors__name__isnull</span>=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>跨越多值的关联关系</p>\n<ul>\n<li><p>选择所有包含 <font color=\"red\">同时满足两个条件的entry的blog</font> ，这两个条件是headline 包含Lennon 和发表时间是2008 <font color=\"red\">（同一个entry 满足两个条件）</font> ，我们的代码是：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.filter(<span class=\"attribute\">entry__headline__contains</span>=<span class=\"string\">'Lennon'</span>, <span class=\"attribute\">entry__pub_date__year</span>=2008)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要选择所有这样的blog，有一个entry的headline包含“Lennon”和有一个entry发表时间是2008，我们将这样编写：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(entry__headline__contains=<span class=\"string\">'Lennon'</span>).<span class=\"attribute\">filter</span>(entry__pub_date__year=<span class=\"number\">2008</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假设这里有一个blog拥有一条包含’Lennon’的entries条目和一条来自2008的entries条目,但是没有一条来自2008并且包含”Lennon”的entries条目。 第一个查询不会返回任何blog，第二个查询将会返回一个blog。</p>\n</li>\n<li><p>在第二个例子中， 第一个filter限定查询集为所有与headline包含“Lennon”的entry关联的blog。 第二个filter进一步限定查询集中的blog，这些blog关联的entry 的发表时间是2008。 第二个filter 过滤出来的entry 与第一个filter 过滤出来的entry 可能相同也可能不同。 <font color=\"red\">我们用每个filter语句过滤的是Blog，而不是Entry。</font></p>\n</li>\n<li><p>跨越多值关系的filter() 查询的行为，与exclude() 实现的不同。 单个exclude() 调用中的条件不必引用同一个记录。</p>\n</li>\n<li><p>例如，下面的查询将<font color=\"red\">排除两种 </font>entry的blog，headline中包含“Lennon”的entry和在2008年发布的entry：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.exclude(</span><br><span class=\"line\">    <span class=\"attribute\">entry__headline__contains</span>=<span class=\"string\">'Lennon'</span>,</span><br><span class=\"line\">    <span class=\"attribute\">entry__pub_date__year</span>=2008,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而，这与使用filter() 的行为不同，它不是排除<font color=\"red\">同时满足</font>两个条件的Entry。 为了实现这点，即选择的Blog中不包含在2008年发布且healine 中带有“Lennon” 的Entry，你需要编写两个查询：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog.objects.exclude(</span><br><span class=\"line\">    <span class=\"attribute\">entry__in</span>=Entry.objects.filter(</span><br><span class=\"line\">        <span class=\"attribute\">headline__contains</span>=<span class=\"string\">'Lennon'</span>,</span><br><span class=\"line\">        <span class=\"attribute\">pub_date__year</span>=2008,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>过滤器可以引用模型的字段</p>\n<ul>\n<li><p>查询表达式</p>\n<ul>\n<li>文档：<a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/expressions.html#django.db.models.F\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/expressions.html#django.db.models.F</a>  <img src=\"http://pdp5bkqjj.bkt.clouddn.com/images/F.png\">\n</li>\n</ul>\n</li>\n<li><p>将模型的一个字段与同一个模型的另外一个字段进行比较</p>\n</li>\n<li><p>Django 提供F表达式 来允许这样的比较。 <font color=\"red\">F() 返回的实例用作查询内部对模型字段的引用。</font> 这些引用可以用于查询的filter 中来<font color=\"red\">比较相同模型实例上</font>不同字段之间值的比较。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，为了查找comments 数目多于pingbacks 的Entry，我们将构造一个F() 对象来引用pingback 数目，并在查询中使用该F() 对象：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; from django<span class=\"selector-class\">.db</span><span class=\"selector-class\">.models</span> import F</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(n_comments__gt=F(<span class=\"string\">'n_pingbacks'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Django 支持对F() 对象使用加法、减法、乘法、除法、取模以及幂计算等算术操作，两个操作数可以都是常数和其它F() 对象。</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了查找comments 数目比pingbacks 两倍还要多的<span class=\"keyword\">Entry</span>，我们将查询修改为：</span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">Entry</span>.objects.filter(n_comments__gt=F(<span class=\"symbol\">'n_pingbacks</span>') * <span class=\"number\">2</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">为了查询rating 比pingback 和comment 数目总和要小的<span class=\"keyword\">Entry</span>，我们将这样查询：</span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">Entry</span>.objects.filter(rating__lt=F(<span class=\"symbol\">'n_comments</span>') + F(<span class=\"symbol\">'n_pingbacks</span>'))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你还可以在F() 对象中使用双下划线标记来跨越关联关系。 带有双下划线的F() 对象将引入任何需要的join 操作以访问关联的对象。 </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，如要获取author 的名字与blog 名字相同的Entry，我们可以这样查询：</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(authors__name=F(<span class=\"string\">'blog__name'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于date 和date/time 字段，你可以给它们加上或减去一个timedelta 对象。 </p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下面的例子将返回发布超过<span class=\"number\">3</span>天后被修改的所有Entry：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; from datetime import timedelta</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(mod_date__gt=F(<span class=\"string\">'pub_date'</span>) + timedelta(days=<span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>pk查找快捷方式</p>\n<ul>\n<li><p>为了方便，Django 提供一个查询快捷方式pk ，它表示“primary key” 的意思</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在示例Blog模型中，主键pk是id字段，所以这三个语句是等价的：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id__exact</span>=14) # Explicit form</span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id</span>=14) # __exact is implied</span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=14) # pk implies id__exact</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pk的使用并不限于__ exact查询 - 任何查询词都可以与pk组合来执行查询一个模型的primary key：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Get blogs entries with id <span class=\"number\">1</span>, <span class=\"number\">4</span> and <span class=\"number\">7</span></span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.filter(pk__in=[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"># Get all blog entries with id &gt; <span class=\"number\">14</span></span><br><span class=\"line\">&gt;&gt;&gt; Blog.objects.filter(pk__gt=<span class=\"number\">14</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pk查询在join 中也可以工作。 例如，下面三个语句是等同的：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(blog__id__exact=<span class=\"number\">3</span>) <span class=\"comment\"># Explicit form</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(blog__id=<span class=\"number\">3</span>)        <span class=\"comment\"># __exact is implied</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.filter(blog__pk=<span class=\"number\">3</span>)        <span class=\"comment\"># __pk implies __id__exact</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>在LIKE语句中转义百分号和下划线</p>\n<ul>\n<li><p>与endswith SQL 语句等同的字段查询（LIKE、 istartswith、isendswith、isexact、 LIKE、startswith 和contains）将自动转义在contains 语句中使用的两个特殊的字符 —— 百分号和下划线。 （在LIKE 语句中，百分号通配符表示多个字符，下划线通配符表示单个字符）。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，要获取包含一个百分号的所有的Entry，只需要像其它任何字符一样使用百分号：</span><br><span class=\"line\">&gt;&gt;&gt; Entry.objects.filter(headline__contains=<span class=\"string\">'%'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">Django照顾你的引用；生成的SQL将如下所示：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"params\">...</span> <span class=\"keyword\">WHERE</span> headline LIKE <span class=\"string\">'%\\%%'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>缓存和QuerySet</p>\n<ul>\n<li>每个QuerySet都包含一个缓存来最小化对数据库的访问。 理解它是如何工作的将让你编写最高效的代码。</li>\n<li><p>在一个新创建的QuerySet中，缓存为空。 首次对QuerySet进行求值 —— 同时发生数据库查询 ——Django <font color=\"red\">将保存查询的结果到QuerySet的缓存中并返回明确请求的结果</font>（例如，如果正在迭代QuerySet，则返回下一个结果）。 接下来对该QuerySet 的求值将重用缓存的结果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请牢记这个缓存行为，因为对QuerySet使用不当的话，它会坑你的。 例如，下面的语句创建两个QuerySet，对它们求值，然后扔掉它们：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([e.headline <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> Entry.objects.all()])</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([e.pub_date <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> Entry.objects.all()])</span></span><br><span class=\"line\">这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。 同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Entry被添加进来或删除掉。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">为了避免这个问题，只需保存QuerySet并重新使用它：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; queryset = Entry.objects.all()</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([p.headline <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> queryset]) <span class=\"comment\"># Evaluate the query set.</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>([p.pub_date <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> queryset]) <span class=\"comment\"># Re-use the cache from the evaluation.</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>当QuerySet不缓存</p>\n<ul>\n<li><p>查询集不会永远缓存它们的结果。 当只对查询集的部分进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。 特别地，这意味着使用切片或索引来limiting the queryset将不会填充缓存。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，重复获取查询集对象中一个特定的索引将每次都查询数据库：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; queryset = Entry.objects.all()</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Queries the database</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Queries the database again</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">然而，如果已经对全部查询集求值过，则将检查缓存：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; queryset = Entry.objects.all()</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; [entry <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> queryset] <span class=\"comment\"># Queries the database</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Uses cache</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(queryset[5]) <span class=\"comment\"># Uses cache</span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">下面是一些其它例子，它们会使得全部的查询集被求值并填充到缓存中：</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; [entry <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> queryset]</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; bool(queryset)</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; entry <span class=\"keyword\">in</span> queryset</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; list(queryset)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>使用Q对象进行复杂查找</p>\n<ul>\n<li>在filter()中的关键字参数查询 — — 是“AND”的关系。 如果你需要执行更复杂的查询（例如OR 语句），你可以使用Q对象。</li>\n<li>Q object (django.db.models.Q) 对象用于封装一组关键字参数。 这些关键字参数就是上文“字段查询” 中所提及的那些。<ul>\n<li>文档： <a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.Q\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/querysets.html#django.db.models.Q</a>  搜索：Q()对象</li>\n</ul>\n</li>\n<li><p>Q对象可以使用&amp;和|操作符组合起来。 当一个操作符在两个Q 对象上使用时，它产生一个新的Q 对象。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，下面的语句产生一个<span class=\"string\">\"question__startswith\"</span> 对象，表示两个Q 查询的“<span class=\"literal\">OR</span>” ：</span><br><span class=\"line\">Q(question__startswith=<span class=\"string\">'Who'</span>) | Q(question__startswith=<span class=\"string\">'What'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">它等同于下面的SQL <span class=\"keyword\">WHERE</span> 子句：</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> question LIKE <span class=\"string\">'Who%'</span> <span class=\"literal\">OR</span> question LIKE <span class=\"string\">'What%'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你可以组合&amp; 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。 同时，~ 对象可以使用NOT 操作符取反，</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这允许组合正常的查询和取反(Q) 查询：</span><br><span class=\"line\">Q(<span class=\"attribute\">question__startswith</span>=<span class=\"string\">'Who'</span>) | ~Q(<span class=\"attribute\">pub_date__year</span>=2005)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>每个接受关键字参数的查询函数（例如filter()、exclude()、get()）都可以传递一个或多个Q 对象作为位置（不带名的）参数。 如果一个查询函数有多个Q 对象参数，这些参数的逻辑关系为“AND”。 像这样：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Poll.objects.get(</span><br><span class=\"line\">    Q(question__startswith='Who'),</span><br><span class=\"line\">    Q(pub_date=date(<span class=\"number\">2005</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>)) | Q(pub_date=date(<span class=\"number\">2005</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">...大致翻译成SQL：</span><br><span class=\"line\">SELECT * from polls WHERE question LIKE 'Who%'</span><br><span class=\"line\">    AND (pub_date = '<span class=\"number\">2005</span><span class=\"number\">-05</span><span class=\"number\">-02</span>' OR pub_date = '<span class=\"number\">2005</span><span class=\"number\">-05</span><span class=\"number\">-06</span>')</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询函数可以混合使用Q和关键字参数。 所有提供给查询函数的参数（关键字参数或Q 对象）都将”AND”在一起。<font color=\"red\"> 但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 </font></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">像这样：</span><br><span class=\"line\">Poll.objects.<span class=\"builtin-name\">get</span>(</span><br><span class=\"line\">    Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 2)) | Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 6)),</span><br><span class=\"line\">    <span class=\"attribute\">question__startswith</span>=<span class=\"string\">'Who'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">..</span>.将是一个有效的查询，相当于前面的例子；但：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># INVALID QUERY</span></span><br><span class=\"line\">Poll.objects.<span class=\"builtin-name\">get</span>(</span><br><span class=\"line\">    <span class=\"attribute\">question__startswith</span>=<span class=\"string\">'Who'</span>,</span><br><span class=\"line\">    Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 2)) | Q(<span class=\"attribute\">pub_date</span>=date(2005, 5, 6))</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">..</span>.不会有效</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>比较对象</p>\n<ul>\n<li>为了比较两个模型实例，只需要使用标准的Python 比较操作符，即双等于符号：==。 在后台，它会比较两个模型主键的值。<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">利用上面的Entry 示例，下面两个语句是等同的：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_entry == other_entry</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_entry.id == other_entry.id</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">如果模型的主键不叫id，也没有问题。 比较将始终使用主键，无论它叫什么。 例如，如果模型的主键字段叫做name，下面的两条语句是等同的：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_obj == other_obj</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; some_obj.name == other_obj.name</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>删除对象</p>\n<ul>\n<li><p>删除方法，为了方便，就取名为delete()。 该方法立即删除对象，并返回一个字典，该字典包含着删除的对象数量和每个对象类型的删除次数。 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.delete()</span><br><span class=\"line\">(<span class=\"number\">1</span>, &#123;<span class=\"string\">'weblog.Entry'</span>: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你还可以批量删除对象。 每个QuerySet 都有一个delete() 方法，它将删除该QuerySet中的所有成员。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，下面的语句删除pub_date 为<span class=\"number\">2005</span> 的所有Entry 对象：</span><br><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.filter</span>(pub_date__year=<span class=\"number\">2005</span>).delete()</span><br><span class=\"line\">(<span class=\"number\">5</span>, &#123;<span class=\"string\">'webapp.Entry'</span>: <span class=\"number\">5</span>&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当Django 删除一个对象时，它默认使用SQL ON DELETE CASCADE 约束 —— 换句话讲，任何有外键指向要删除对象的对象将一起删除。 像这样：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=1)</span><br><span class=\"line\"><span class=\"comment\"># This will delete the Blog and all of its Entry objects.</span></span><br><span class=\"line\">b.delete()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，delete()是唯一没有在Manager上暴露出来的QuerySet方法。 这是一个安全机制来防止你意外地请求Entry.objects.delete()，而删除所有 的条目。 <font color=\"red\">如果你确实想删除所有的对象，你必须明确地请求一个完全的查询集：</font></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Entry</span><span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>()<span class=\"selector-class\">.delete</span>()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>一次更新多个对象  </p>\n<ul>\n<li><p>有时你想为一个QuerySet中所有对象的某个字段都设置一个特定的值。 这时你可以使用update() 方法。 像这样：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Update <span class=\"keyword\">all</span> the headlines <span class=\"keyword\">with</span> pub_date <span class=\"keyword\">in</span> <span class=\"number\">2007</span></span><br><span class=\"line\"><span class=\"keyword\">Entry</span>.objects.filter(pub_date__year=<span class=\"number\">2007</span>).update(headline=<span class=\"symbol\">'Everything</span> <span class=\"keyword\">is</span> the same')</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你只可以对非关联字段和ForeignKey 字段使用这个方法。 若要更新一个非关联字段，只需提供一个新的常数值。 <font color=\"red\">若要更新ForeignKey 字段，需设置新的值为你想指向的新的模型实例</font>。 像这样：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; b = Blog.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">pk</span>=1)</span><br><span class=\"line\"><span class=\"comment\"># Change every Entry so that it belongs to this Blog.</span></span><br><span class=\"line\">&gt;&gt;&gt; Entry.objects.all().update(<span class=\"attribute\">blog</span>=b)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>update() 方法会立即执行并返回查询匹配的行数（如果有些行已经具有新的值，返回的行数可能和被更新的行数不相等）。 正在更新的QuerySet的唯一限制是它只能访问一个数据库表：模型的主表。 <font color=\"red\">你可以根据关联的字段过滤，但是你只能更新模型主表中的列。</font> 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog.objects.get(pk=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># Update all the headlines belonging to this Blog.</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.select_related().filter(blog=b).update(headline=<span class=\"string\">'Everything is the same'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要注意update() 方法会直接转换成一个SQL 语句。 它是一个批量的直接更新操作。 它不会运行模型的save() 方法，或者发出pre_save 或 post_save信号（调用save()方法产生）或者查看auto_now 字段选项。 如果你想保存QuerySet中的每个条目并确保每个实例的save() 方法都被调用，你不需要使用任何特殊的函数来处理。 只需要迭代它们并调用save()：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">item</span> <span class=\"keyword\">in</span> my_queryset:</span><br><span class=\"line\">    <span class=\"built_in\">item</span>.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对update 的调用也可以使用F expressions 来根据模型中的一个字段更新另外一个字段。 这对于在当前值的基础上加上一个值特别有用。 例如，增加Blog 中每个Entry 的pingback 个数：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; Entry<span class=\"selector-class\">.objects</span><span class=\"selector-class\">.all</span>().update(n_pingbacks=F(<span class=\"string\">'n_pingbacks'</span>) + <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然而，与filter 和exclude 子句中的F() 对象不同，<font color=\"red\">在update 中你不可以使用F() 对象引入join —— 你只可以引用正在更新的模型的字段</font>。 如果你尝试使用F()对象引入一个join，将引发一个FieldError：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This will raise a FieldError</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Entry.objects.update(headline=F(<span class=\"string\">'blog__name'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><font color=\"red\">一对多关系</font>  \n\n<ul>\n<li><font color=\"red\">正向查询：</font></li>\n<li><p>如果一个模型具有ForeignKey，那么该模型的实例将可以通过属性访问关联的（外部）对象。 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e = Entry.objects.get(id=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.blog <span class=\"comment\"># Returns the related Blog object.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你可以通过外键属性获取和设置。 和你预期的一样，对外键的修改不会保存到数据库中直至你调用save()。 例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e = Entry.objects.get(id=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.blog = some_blog</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.save()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果ForeignKey 字段有NULL 设置（即它允许null=True 值），你可以分配None 来删除对应的关联性。  例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e = Entry.objects.get(id=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.blog = None</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; e.save() <span class=\"comment\"># \"UPDATE blog_entry SET blog_id = NULL ...;\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一对多关联关系的前向访问在第一次访问关联的对象时被缓存。 以后对同一个对象的外键的访问都使用缓存。  例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; e = Entry.objects.get(id=2)</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(e.blog)  <span class=\"comment\"># Hits the database to retrieve the associated Blog.</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt; <span class=\"built_in\">print</span>(e.blog)  <span class=\"comment\"># Doesn't hit the database; uses cached version.</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意select_related() QuerySet方法递归地预填充所有的一对多关系到缓存中。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n</li>\n<li><font color=\"red\">反向查询</font></li>\n<li><p>如果模型有一个ForeignKey，那么该ForeignKey所指的模型实例可以通过一个Manager返回第一个模型的所有实例。 默认情况下，这个Manager的名字为FOO_set，其中FOO是源模型的小写名称。 该Manager返回QuerySets，可以用上一节提到的方式进行过滤和操作。例如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog.objects.get(id=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entry_set.all() <span class=\"comment\"># Returns all Entry objects related to Blog.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b.entry_set is a Manager that returns QuerySets.</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entry_set.filter(headline__contains=<span class=\"string\">'Lennon'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entry_set.count()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>你可以在ForeignKey 定义时设置related_name 参数来覆盖FOO_set 的名称。 例如，如果Entry模型更改为blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)，上述示例代码如下所示：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b = Blog.objects.get(id=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entries.all() <span class=\"comment\"># Returns all Entry objects related to Blog.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b.entries is a Manager that returns QuerySets.</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entries.filter(headline__contains=<span class=\"string\">'Lennon'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; b.entries.count()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理关联对象其他方法</p>\n<ul>\n<li><a href=\"https://yiyibooks.cn/xx/Django_1.11.6/ref/models/relations.html\" target=\"_blank\" rel=\"noopener\">https://yiyibooks.cn/xx/Django_1.11.6/ref/models/relations.html</a></li>\n<li>add（），create（），remove（），set（）</li>\n</ul>\n</li>\n<li><font color=\"red\">这一节中提到的每个”反向“操作都会立即对数据库产生作用。 每个添加、创建和删除操作都会立即并自动保存到数据库中。</font>\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>多对多关系</p>\n<ul>\n<li>多对多关系的两端都会自动获得访问另一端的API。 这些API 的工作方式与上面提到的“方向”一对多关系一样。</li>\n<li>唯一的区别在于属性的命名：定义 ManyToManyField 的模型使用该字段的属性名称，而“反向”模型使用源模型的小写名称加上’_set’ （和一对多关系一样）。</li>\n<li><p>例如：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e = Entry.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id</span>=3)</span><br><span class=\"line\">e.authors.all() # Returns all Author objects <span class=\"keyword\">for</span> this Entry.</span><br><span class=\"line\">e.authors.count()</span><br><span class=\"line\">e.authors.filter(<span class=\"attribute\">name__contains</span>=<span class=\"string\">'John'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">a = Author.objects.<span class=\"builtin-name\">get</span>(<span class=\"attribute\">id</span>=5)</span><br><span class=\"line\">a.entry_set.all() # Returns all Entry objects <span class=\"keyword\">for</span> this Author.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类似ForeignKey，ManyToManyField 可以指定related_name。 在上面的例子中，如果entry_set 中的ManyToManyField 指定entries，那么Entry 实例将使用 related_name=’entries’ 属性而不是Author。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>一对一关系</p>\n<ul>\n<li>一对一关系与多对一关系非常相似。 如果你在模型中定义一个OneToOneField，该模型的实例将可以通过该模型的一个简单属性访问关联的模型。</li>\n<li><p>例如：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">EntryDetail</span>(<span class=\"title\">models</span>.<span class=\"type\">Model</span>):</span></span><br><span class=\"line\"><span class=\"class\">entry = models.<span class=\"type\">OneToOneField</span>(<span class=\"type\">Entry</span>, <span class=\"title\">on_delete</span>=<span class=\"title\">models</span>.<span class=\"type\">CASCADE</span>)</span></span><br><span class=\"line\"><span class=\"class\">details = models.<span class=\"type\">TextField</span>()</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">ed = <span class=\"type\">EntryDetail</span>.objects.get(<span class=\"title\">id</span>=2)</span></span><br><span class=\"line\"><span class=\"class\">ed.entry # <span class=\"type\">Returns</span> the related <span class=\"type\">Entry</span> object.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在“反向”查询中有所不同。 一对一关系中的关联模型同样具有一个Manager对象，但是该Manager表示一个单一的对象而不是对象的集合：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e = Entry.objects.<span class=\"keyword\">get</span>(<span class=\"built_in\">id</span>=<span class=\"number\">2</span>)</span><br><span class=\"line\">e.entrydetail <span class=\"comment\"># returns the related EntryDetail object</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h3><h3 id=\"视图（View）\"><a href=\"#视图（View）\" class=\"headerlink\" title=\"视图（View）\"></a>视图（View）</h3><h3 id=\"模板（templates）\"><a href=\"#模板（templates）\" class=\"headerlink\" title=\"模板（templates）\"></a>模板（templates）</h3><h3 id=\"setting文件\"><a href=\"#setting文件\" class=\"headerlink\" title=\"setting文件\"></a>setting文件</h3>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjlnxkcyk0000pstf7agevk6j","tag_id":"cjlnxkcyr0002pstflucohgs7","_id":"cjlnxkcyt0003pstfiui1f930"},{"post_id":"cjlnxkcz50004pstf9tti8132","tag_id":"cjlnxkcyr0002pstflucohgs7","_id":"cjlnxkcz90007pstff2z2bveg"},{"post_id":"cjlnxkcz70006pstfbuf71c3p","tag_id":"cjlnxkcyr0002pstflucohgs7","_id":"cjlnxkczb0009pstfepwxdwsb"},{"post_id":"cjlnxkcz90008pstf95jcrh3u","tag_id":"cjlnxkczc000bpstf2zipcckk","_id":"cjlnxkczf000dpstfy7z1uy5k"},{"post_id":"cjlnxkczb000apstfbi7jl9e8","tag_id":"cjlnxkczc000bpstf2zipcckk","_id":"cjlnxkczg000epstfhnxtzyh4"},{"post_id":"cjlnxkczw000fpstfpy24rgao","tag_id":"cjlnxkcyr0002pstflucohgs7","_id":"cjlnxkczz000gpstfhzu4oqox"}],"Tag":[{"name":"Django","_id":"cjlnxkcyr0002pstflucohgs7"},{"name":"Linux","_id":"cjlnxkczc000bpstf2zipcckk"}]}}